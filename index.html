<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Orb.exe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: black; font-family: 'Monospace', monospace; touch-action: none; }
        canvas { display: block; }
        
        #ui-wrapper {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #ui-header {
            background: #222;
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border: 1px solid #444;
            user-select: none;
        }

        #ui-wrapper.cyber-mode #ui-header {
            background: transparent;
            border: none;
            padding: 0;
            justify-content: flex-end;
            pointer-events: none;
            gap: 10px;
        }
        
        #ui-wrapper.cyber-mode #ui-header span {
            display: none;
        }

        .header-btn {
            background: #222;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            padding: 5px 12px;
            cursor: pointer;
            pointer-events: auto;
            font-weight: bold;
            font-family: inherit;
        }
        .header-btn:hover { background: #444; }
        .header-btn.active { background: #00aa00; border-color: #0f0; }

        #btn-aim-toggle { display: none; }
        #ui-wrapper.cyber-mode #btn-aim-toggle { display: block; }

        #ui-content {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, border 0.3s;
            border: none; 
        }

        #ui-wrapper.open #ui-content {
            max-height: 80vh;
            border: 1px solid #444; 
            border-top: none;
        }
        
        #ui-wrapper.cyber-mode.open #ui-header {
             pointer-events: auto; 
        }

        .tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
        }

        .tab {
            flex: 1;
            padding: 10px 0;
            text-align: center;
            cursor: pointer;
            font-size: 10px;
            color: #888;
            background: #1a1a1a;
            border: none;
            font-family: 'Monospace', monospace;
        }

        .tab.active {
            color: white;
            background: #333;
            font-weight: bold;
        }

        .tab-content {
            padding: 15px;
            display: none;
            overflow-y: auto;
            max-height: 60vh;
        }

        .tab-content.active { display: block; }

        .row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 12px; 
            flex-wrap: wrap;
        }
        
        .label { font-size: 12px; font-weight: bold; color: #ccc; }
        
        button.action-btn {
            background: #333; color: white; border: 1px solid #666; 
            padding: 6px 10px; cursor: pointer; font-family: inherit; width: 100%;
            border-radius: 4px;
            margin-top: 5px;
            font-family: 'Monospace', monospace;
        }
        button.action-btn:hover { background: #555; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        input[type="color"] { border: none; width: 30px; height: 30px; padding: 0; background: none; cursor: pointer; }
        input[type="range"] { flex-grow: 1; margin: 0 10px; cursor: pointer; }
        input[type="number"] { width: 60px; background: #222; border: 1px solid #555; color: white; padding: 2px; font-family: 'Monospace', monospace; margin-left: 5px; }
        input[type="checkbox"] { transform: scale(1.2); cursor: pointer; }

        #tab-cyber-btn { display: none; }
        #tab-cyber-btn.visible { display: block; }
        .secret-setting { display: none; }
        .secret-setting.visible { display: flex; }

        #cyber-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border: 1px solid #444;
            display: none;
            pointer-events: none;
            user-select: none;
            text-align: center;
            line-height: 1.6;
            opacity: 1;
            transition: opacity 1s ease-out; 
            z-index: 60;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            mix-blend-mode: difference;
            z-index: 50;
        }

        #hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            display: none;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            z-index: 90;
        }

        #compass {
            width: 60px;
            height: 60px;
            border: 2px solid #555;
            border-radius: 50%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }

        #compass-arrow {
            color: #ff3333;
            font-size: 24px;
            font-weight: bold;
            transform-origin: center;
            display: block;
        }

        #coords {
            color: #ffffff;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border: 1px solid #444;
            font-size: 12px;
            font-family: monospace;
        }

        #npc-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 80;
        }

        .npc-dialogue {
            position: absolute;
            background: white;
            color: black;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            opacity: 0.9;
            font-weight: bold;
            display: none;
        }
        .npc-dialogue::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: white transparent transparent transparent;
        }

        #mobile-ui {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        #joystick-area {
            position: absolute;
            bottom: 40px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #mobile-buttons {
            position: absolute;
            bottom: 30px;
            right: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            pointer-events: auto;
        }

        .mob-btn {
            width: 65px;
            height: 65px;
            background: rgba(50, 50, 50, 0.7);
            border: 1px solid #888;
            border-radius: 50%;
            color: white;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            cursor: pointer;
        }
        .mob-btn:active { background: rgba(100, 100, 100, 0.9); }

        #interaction-ui {
            display: none;
            position: absolute;
            bottom: 180px;
            right: 20px;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            z-index: 51;
        }
        
        .interact-btn {
            width: 80px;
            height: 40px;
            background: rgba(0, 100, 200, 0.6);
            border: 1px solid #8cf;
            color: white;
            font-weight: bold;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        .interact-btn.throw { background: rgba(200, 50, 50, 0.6); border-color: #f88; }
        .interact-btn.drop { background: rgba(100, 100, 100, 0.6); border-color: #ccc; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="hud-top-left">
        <div id="compass"><span id="compass-arrow">▲</span></div>
        <div id="coords">X: 0 Y: 0</div>
    </div>
    
    <div id="npc-container"></div>

    <div id="cyber-overlay">
        HOLD [R-CLICK] OR TOGGLE [ALT/⊕] TO LOOK<br>
        HOLD [L-CLICK] TO GRAB | SCROLL TO PUSH/PULL<br>
        [T] THROW | [C] CROUCH | [SHIFT] SPRINT<br>
        WASD TO MOVE
    </div>

    <div id="ui-wrapper">
        <div id="ui-header">
            <span>Settings</span>
            <button id="btn-aim-toggle" class="header-btn" title="Toggle Aim Lock (Alt)">⊕</button>
            <button id="ui-toggle-btn" class="header-btn">•••</button>
        </div>
        <div id="ui-content">
            <div class="tabs">
                <button class="tab active" data-target="tab-visual" id="btn-tab-visual">Visual</button>
                <button class="tab" data-target="tab-world">World</button>
                <button class="tab" data-target="tab-behavior">Logic</button>
                <button class="tab" data-target="tab-physics">Physics</button>
                <button class="tab" id="tab-cyber-btn" data-target="tab-cyber">Cyber</button>
            </div>

            <div id="tab-visual" class="tab-content active">
                <div class="row">
                    <button class="action-btn" id="btn-shape">Toggle Shape: Sphere</button>
                </div>
                <div class="row">
                    <span class="label">Mesh Color</span>
                    <input type="color" id="col-mesh" value="#ffffff">
                </div>
                <div class="row">
                    <span class="label">Grid Color</span>
                    <input type="color" id="col-grid" value="#000000">
                </div>
                <div class="row">
                    <span class="label">Display Grid</span>
                    <input type="checkbox" id="chk-grid" checked>
                </div>
                <div class="row">
                    <span class="label">Grid Thickness</span>
                    <input type="range" id="sl-grid-thick" min="1" max="10" step="0.5" value="2">
                    <input type="number" id="num-grid-thick" value="2">
                </div>
                <div class="row">
                    <span class="label">Display Chars</span>
                    <input type="checkbox" id="chk-chars" checked>
                </div>
                <div class="row">
                    <span class="label">Grid Density</span>
                    <input type="range" id="sl-grid" min="10" max="100" value="20">
                    <input type="number" id="num-grid" value="20">
                </div>
                <div class="row">
                    <span class="label">Object Size</span>
                    <input type="range" id="sl-scale" min="0.1" max="3" step="0.1" value="1">
                    <input type="number" id="num-scale" value="1">
                </div>
            </div>

            <div id="tab-world" class="tab-content">
                <div class="row">
                    <span class="label">Sky Color</span>
                    <input type="color" id="col-sky" value="#000000">
                </div>
                <div class="row">
                    <span class="label">Sky Luminance</span>
                    <input type="range" id="sl-luminance" min="0" max="3" step="0.1" value="1">
                    <input type="number" id="num-luminance" value="1">
                </div>
                <div class="row secret-setting" id="row-floor">
                    <span class="label">Floor Color (Physics)</span>
                    <input type="color" id="col-floor" value="#222222">
                </div>
            </div>

            <div id="tab-behavior" class="tab-content">
                <div class="row">
                    <span class="label">Randomizer</span>
                    <input type="checkbox" id="chk-randomizer" checked>
                </div>
                <div class="row">
                    <button class="action-btn" id="btn-shuffle" disabled>Manual Shuffle</button>
                </div>
                <div class="row">
                    <span class="label">Spread Effect</span>
                    <input type="checkbox" id="chk-spread" checked>
                </div>
                <div class="row">
                    <span class="label">Resolution</span>
                    <input type="range" id="sl-res" min="0.1" max="1" step="0.1" value="1">
                    <input type="number" id="num-res" value="1">
                </div>
            </div>

            <div id="tab-physics" class="tab-content">
                <div class="row">
                    <span class="label">Enable Physics</span>
                    <input type="checkbox" id="chk-physics">
                </div>
                <div class="row secret-setting" id="row-gravity">
                    <span class="label">Gravity</span>
                    <input type="range" id="sl-gravity" min="0" max="2" step="0.05" value="0.5">
                    <input type="number" id="num-gravity" value="0.5">
                </div>
            </div>

            <div id="tab-cyber" class="tab-content">
                <div class="row">
                    <span class="label">Cyberspace Mode</span>
                    <input type="checkbox" id="chk-cyberspace">
                </div>
                <div class="row" style="margin-top:10px;">
                     <button class="action-btn" id="btn-backrooms" style="background:#520; display:none;">ENTER ROOMS</button>
                </div>
                
                <div class="row" style="margin-top:10px; border-bottom:1px solid #333; padding-bottom:5px;">
                    <span class="label" style="color:white;">View Settings</span>
                </div>
                <div class="row">
                    <span class="label">Enable Bloom</span>
                    <input type="checkbox" id="chk-bloom" checked>
                </div>
                <div class="row bloom-setting">
                    <span class="label">Bloom Strength</span>
                    <input type="range" id="sl-bloom" min="0" max="3" step="0.1" value="0.4">
                    <input type="number" id="num-bloom" value="0.4">
                </div>
                 <div class="row">
                    <span class="label">View Distance</span>
                    <input type="range" id="sl-view-dist" min="10" max="2000" step="10" value="100">
                    <input type="number" id="num-view-dist" value="100">
                </div>

                <div class="row" style="margin-top:10px; border-bottom:1px solid #333; padding-bottom:5px;">
                    <span class="label" style="color:white;">Zone Settings</span>
                </div>
                <div class="row">
                    <span class="label">Mono NPCs/Buildings</span>
                    <input type="checkbox" id="chk-mono" checked>
                </div>

                <div class="row" style="margin-top:10px; border-bottom:1px solid #333; padding-bottom:5px;">
                    <span class="label" style="color:white;">Flashlight Settings</span>
                </div>
                <div class="row">
                    <span class="label">Color</span>
                    <input type="color" id="col-flash" value="#ffffff">
                </div>
                <div class="row">
                    <span class="label">Brightness</span>
                    <input type="range" id="sl-flash-int" min="0" max="5" step="0.1" value="2">
                    <input type="number" id="num-flash-int" value="2">
                </div>
                <div class="row">
                    <span class="label">Distance</span>
                    <input type="range" id="sl-flash-dist" min="10" max="200" value="50">
                    <input type="number" id="num-flash-dist" value="50">
                </div>
                 <div class="row">
                    <span class="label">Size (Angle)</span>
                    <input type="range" id="sl-flash-angle" min="0.1" max="1.5" step="0.1" value="0.5">
                    <input type="number" id="num-flash-angle" value="0.5">
                </div>
            </div>
        </div>
    </div>

    <script src="js/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="js/OrbitControls.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 20, 100); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100); 
        camera.position.z = 25;
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 0.4;
        bloomPass.radius = 0;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 12;
        controls.maxDistance = 60;

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        const flashLight = new THREE.SpotLight(0xffffff, 0);
        flashLight.position.set(0, 0, 0);
        flashLight.angle = Math.PI / 6;
        flashLight.penumbra = 0.5;
        flashLight.decay = 2;
        flashLight.distance = 50;
        flashLight.castShadow = true;
        flashLight.shadow.bias = -0.0001;
        flashLight.target.position.set(0, 0, -1);
        scene.add(flashLight);
        scene.add(flashLight.target);

        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
        let rows = 20;
        let cols = 40;
        const canvasWidth = 1024; 
        const canvasHeight = 512;
        let gridData = [];
        let meshColor = '#ffffff';
        let gridColor = '#000000';
        let activeWaveState = null; 
        
        let settingRandomizer = true;
        let settingSpread = true;
        let settingPhysics = false;
        let settingShowGrid = true;
        let settingShowChars = true;
        let settingGravity = 0.5;
        let settingGridThick = 2;
        
        let settingCyber = false;
        let flashOn = false;
        let inBackrooms = false;
        let inAbandoned = false;
        let aimLocked = false;
        let settingBloom = true;
        let settingMono = true;
        
        const floorGeometry = new THREE.PlaneGeometry(300, 300);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = -15;
        floorMesh.receiveShadow = true;
        floorMesh.visible = false;
        scene.add(floorMesh);

        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = canvasWidth;
        textureCanvas.height = canvasHeight;
        const ctx = textureCanvas.getContext('2d', { alpha: false });

        const staticCanvas = document.createElement('canvas');
        staticCanvas.width = canvasWidth;
        staticCanvas.height = canvasHeight;
        const staticCtx = staticCanvas.getContext('2d', { alpha: false });
        let staticNeedsUpdate = true;

        const texture = new THREE.CanvasTexture(textureCanvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        let geometrySphere = new THREE.SphereGeometry(10, 64, 64);
        let geometryBox = new THREE.BoxGeometry(14, 14, 14);
        
        const material = new THREE.MeshStandardMaterial({ 
            map: texture, 
            roughness: 0.5,
            metalness: 0.1
        });
        
        let currentMesh = new THREE.Mesh(geometrySphere, material);
        currentMesh.castShadow = true;
        currentMesh.receiveShadow = true;
        scene.add(currentMesh);

        let isSphere = true;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const raycasterPlane = new THREE.Raycaster();

        let objVelocity = new THREE.Vector3(0, 0, 0);
        let isDragging = false;
        let previousDragPosition = new THREE.Vector3();
        
        let isHoldingMobile = false;
        let isHoldingDesktop = false;
        let holdDistance = 15;
        
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isSprinting = false, isCrouching = false;

        let isLooking = false;
        let lastLookX = 0;
        let lastLookY = 0;

        const brGroup = new THREE.Group();
        scene.add(brGroup);
        const brWallGeo = new THREE.BoxGeometry(10, 20, 10);
        
        const noiseCanvas = document.createElement('canvas');
        noiseCanvas.width = 256; noiseCanvas.height = 256;
        const nCtx = noiseCanvas.getContext('2d');
        nCtx.fillStyle = '#C2B280'; 
        nCtx.fillRect(0,0,256,256);
        for(let i=0; i<8000; i++) {
            nCtx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.06)' : 'rgba(255,255,255,0.06)';
            const x = Math.random()*256;
            const y = Math.random()*256;
            nCtx.fillRect(x, y, 2, 2);
        }
        const wallTex = new THREE.CanvasTexture(noiseCanvas);
        
        const tileCanvas = document.createElement('canvas');
        tileCanvas.width = 256; tileCanvas.height = 256;
        const tCtx = tileCanvas.getContext('2d');
        tCtx.fillStyle = '#A6A68C'; 
        tCtx.fillRect(0,0,256,256);
        tCtx.strokeStyle = 'rgba(0,0,0,0.15)';
        tCtx.lineWidth = 4;
        tCtx.strokeRect(0,0,256,256); 
        const ceilTex = new THREE.CanvasTexture(tileCanvas);
        
        const brWallMat = new THREE.MeshStandardMaterial({map: wallTex});
        const brFloorGeo = new THREE.PlaneGeometry(10, 10);
        const brFloorMat = new THREE.MeshStandardMaterial({color: 0x554433}); 
        const brCeilMat = new THREE.MeshStandardMaterial({map: ceilTex});
        
        const brLightGeo = new THREE.PlaneGeometry(2, 8);
        const brLightMat = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide});
        
        const doorCanvas = document.createElement('canvas');
        doorCanvas.width = 64; doorCanvas.height = 128;
        const dCtx = doorCanvas.getContext('2d');
        dCtx.fillStyle = '#443322'; dCtx.fillRect(0,0,64,128);
        dCtx.strokeStyle = '#221100'; dCtx.lineWidth = 2; dCtx.beginPath();
        dCtx.arc(32, 64, 20, 0, Math.PI*2); dCtx.stroke();
        dCtx.strokeRect(5,5,54,118);
        const doorTex = new THREE.CanvasTexture(doorCanvas);
        const brDoorGeo = new THREE.BoxGeometry(6, 16, 11);
        const brDoorMat = new THREE.MeshStandardMaterial({map: doorTex});
        
        const abdGroup = new THREE.Group();
        scene.add(abdGroup);
        const abdChunkSize = 200; 
        
        const brChunkSize = 6; 
        const brTileSize = 10;
        let loadedChunks = {};
        let loadedAbdChunks = {};
        let interactables = [];
        let npcs = [];

        function initGrid() {
            cols = rows * 2; 
            gridData = [];
            for (let y = 0; y < rows; y++) {
                const row = [];
                for (let x = 0; x < cols; x++) {
                    row.push({
                        char: chars[Math.floor(Math.random() * chars.length)],
                        frozen: false,
                        frozenChar: ''
                    });
                }
                gridData.push(row);
            }
            staticNeedsUpdate = true;
        }

        function updateStaticLayer() {
            const cellWidth = canvasWidth / cols;
            const cellHeight = canvasHeight / rows;

            staticCtx.fillStyle = meshColor;
            staticCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (settingShowGrid) {
                staticCtx.lineWidth = settingGridThick; 
                staticCtx.strokeStyle = gridColor;
                staticCtx.beginPath();
                for (let i = 0; i <= cols; i++) {
                    const x = Math.floor(i * cellWidth);
                    staticCtx.moveTo(x, 0);
                    staticCtx.lineTo(x, canvasHeight);
                }
                for (let i = 0; i <= rows; i++) {
                    const y = Math.floor(i * cellHeight);
                    staticCtx.moveTo(0, y);
                    staticCtx.lineTo(canvasWidth, y);
                }
                staticCtx.stroke();
            }
            staticNeedsUpdate = false;
        }

        function drawCanvas() {
            if (staticNeedsUpdate) updateStaticLayer();
            ctx.drawImage(staticCanvas, 0, 0);

            if (settingShowChars) {
                const cellWidth = canvasWidth / cols;
                const cellHeight = canvasHeight / rows;

                ctx.fillStyle = gridColor;
                ctx.font = `bold ${Math.floor(cellHeight * 0.7)}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const cell = gridData[y][x];
                        if (!cell.frozen && settingRandomizer) {
                            if (Math.random() > 0.1) cell.char = chars[Math.floor(Math.random() * chars.length)];
                        } else if (cell.frozen) {
                            cell.char = cell.frozenChar;
                        }
                        const posX = (x * cellWidth) + (cellWidth / 2);
                        const posY = (y * cellHeight) + (cellHeight / 2);
                        ctx.fillText(cell.char, posX, posY);
                    }
                }
            }
            texture.needsUpdate = true;
        }

        let frameCount = 0;
        function updateDominos() {
            if (!settingSpread || activeWaveState === null || frameCount % 4 !== 0) return;
            const cellsToFlip = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (gridData[y][x].frozen === activeWaveState) {
                        const neighbors = [{r:y-1,c:x}, {r:y+1,c:x}, {r:y,c:x-1}, {r:y,c:x+1}];
                        neighbors.forEach(n => {
                            let nr = n.r, nc = n.c;
                            if (nc < 0) nc = cols - 1; if (nc >= cols) nc = 0;
                            if (nr >= 0 && nr < rows) {
                                if (gridData[nr][nc].frozen !== activeWaveState) {
                                    cellsToFlip.push({ r: nr, c: nc, char: gridData[y][x].frozenChar });
                                }
                            }
                        });
                    }
                }
            }
            cellsToFlip.forEach(item => {
                const cell = gridData[item.r][item.c];
                cell.frozen = activeWaveState;
                if (activeWaveState === true) cell.frozenChar = item.char;
            });
        }

        function updatePhysics() {
            if (!settingPhysics) {
                currentMesh.position.set(0,0,0);
                currentMesh.rotation.set(0,0,0);
                objVelocity.set(0,0,0);
                return;
            }

            if(settingPhysics && !inBackrooms && !inAbandoned) {
                floorMesh.position.x = camera.position.x;
                floorMesh.position.z = camera.position.z;
            }

            if (isDragging) return;

            if (isHoldingMobile || isHoldingDesktop) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                const targetPos = camera.position.clone().add(forward.multiplyScalar(holdDistance));
                currentMesh.position.lerp(targetPos, 0.1);
                objVelocity.set(0,0,0);
                currentMesh.rotation.x += 0.01;
                currentMesh.rotation.y += 0.01;
                return;
            }

            objVelocity.y -= settingGravity * 0.1;
            objVelocity.x *= 0.98; 
            objVelocity.z *= 0.98;

            currentMesh.position.add(objVelocity);
            currentMesh.rotation.x += objVelocity.z * 0.05;
            currentMesh.rotation.z -= objVelocity.x * 0.05;

            const floorY = -15;
            const radius = (isSphere ? 10 : 9) * currentMesh.scale.y; 

            if (currentMesh.position.y - radius < floorY) {
                currentMesh.position.y = floorY + radius;
                objVelocity.y *= -0.7; 
                if (Math.abs(objVelocity.y) < 0.1) objVelocity.y = 0;
                objVelocity.x *= 0.7;
                objVelocity.z *= 0.7;
            }
        }

        function pseudoRandom(x, y) {
            return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
        }

        function updateBackrooms() {
            const px = Math.floor(camera.position.x / (brChunkSize * brTileSize));
            const pz = Math.floor(camera.position.z / (brChunkSize * brTileSize));

            const neededKeys = [];
            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    neededKeys.push(`${px + dx},${pz + dz}`);
                }
            }

            Object.keys(loadedChunks).forEach(key => {
                if (!neededKeys.includes(key)) {
                    brGroup.remove(loadedChunks[key]);
                    interactables = interactables.filter(obj => !loadedChunks[key].children.includes(obj));
                    delete loadedChunks[key];
                }
            });

            neededKeys.forEach(key => {
                if (!loadedChunks[key]) {
                    const [cx, cz] = key.split(',').map(Number);
                    const chunkMesh = generateChunk(cx, cz);
                    loadedChunks[key] = chunkMesh;
                    brGroup.add(chunkMesh);
                }
            });
        }

        function generateChunk(cx, cz) {
            const meshGroup = new THREE.Group();
            
            for(let x=0; x<brChunkSize; x++) {
                for(let z=0; z<brChunkSize; z++) {
                    const wx = (cx * brChunkSize + x);
                    const wz = (cz * brChunkSize + z);
                    const rand = pseudoRandom(wx, wz);
                    
                    const posX = wx * brTileSize;
                    const posZ = wz * brTileSize;
                    
                    const fl = new THREE.Mesh(brFloorGeo, brFloorMat);
                    fl.rotation.x = -Math.PI/2;
                    fl.position.set(posX, -15, posZ);
                    fl.receiveShadow = true;
                    meshGroup.add(fl);
                    
                    const cl = new THREE.Mesh(brFloorGeo, brCeilMat);
                    cl.rotation.x = Math.PI/2;
                    cl.position.set(posX, 5, posZ);
                    meshGroup.add(cl);

                    if (pseudoRandom(wx+0.1, wz+0.1) > 0.8) {
                        const light = new THREE.Mesh(brLightGeo, brLightMat);
                        light.rotation.x = Math.PI/2;
                        light.position.set(posX, 4.9, posZ);
                        meshGroup.add(light);
                    }

                    if (rand > 0.7) {
                        const wall = new THREE.Mesh(brWallGeo, brWallMat);
                        wall.position.set(posX, -5, posZ);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        meshGroup.add(wall);

                        if (rand > 0.90) {
                            const door = new THREE.Mesh(brDoorGeo, brDoorMat);
                            if (pseudoRandom(wx, wz+0.5) > 0.5) door.rotation.y = Math.PI/2;
                            door.position.set(posX, -6, posZ);
                            door.userData = { type: 'door' };
                            meshGroup.add(door);
                            interactables.push(door);
                        }
                    }
                }
            }
            return meshGroup;
        }

        function checkCollision(x, z) {
            if(!inBackrooms) return false;
            const gridX = Math.round(x / brTileSize);
            const gridZ = Math.round(z / brTileSize);
            const rand = pseudoRandom(gridX, gridZ);
            return rand > 0.7; 
        }
        
        class NPC {
            constructor(x, z) {
                const group = new THREE.Group();
                const col = settingMono ? new THREE.Color(0xffffff) : new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
                const cone = new THREE.Mesh(new THREE.ConeGeometry(2, 6, 8), new THREE.MeshStandardMaterial({color: col}));
                cone.position.y = -12;
                const head = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), new THREE.MeshStandardMaterial({color: col}));
                head.position.y = -8;
                group.add(cone); group.add(head);
                group.position.set(x, 0, z);
                this.mesh = group;
                this.vel = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize().multiplyScalar(0.1);
                this.timer = 0;
                this.isPaused = false;
                
                this.textEl = document.createElement('div');
                this.textEl.className = 'npc-dialogue';
                const phrases = ["Hello, are you lost too?", "I have been roaming this land for so long.", "I want to go home.", "Hi there.", "...", "I can't remember my name.", "I lost something here.", "I lost someone here."];
                this.textEl.innerText = phrases[Math.floor(Math.random()*phrases.length)];
                document.getElementById('npc-container').appendChild(this.textEl);
                this.mesh.userData = { npc: this };
                interactables.push(this.mesh.children[0]); 
                interactables.push(this.mesh.children[1]);
                abdGroup.add(group);
            }
            update() {
                if(!this.isPaused) {
                    this.timer++;
                    if(this.timer > 200) {
                        this.vel.set(Math.random()-0.5, 0, Math.random()-0.5).normalize().multiplyScalar(0.1);
                        this.timer = 0;
                    }
                    this.mesh.position.add(this.vel);
                }
                
                const pos = this.mesh.position.clone().add(new THREE.Vector3(0, -4, 0));
                pos.project(camera);
                const x = (pos.x * .5 + .5) * window.innerWidth;
                const y = (-(pos.y * .5) + .5) * window.innerHeight;
                
                if (pos.z < 1 && this.mesh.position.distanceTo(camera.position) < 50) {
                    this.textEl.style.left = x + 'px';
                    this.textEl.style.top = y + 'px';
                } else {
                     this.textEl.style.display = 'none';
                }
            }
            interact() {
                this.textEl.style.display = 'block';
                this.isPaused = true;
                setTimeout(() => { 
                    this.textEl.style.display = 'none'; 
                    this.isPaused = false;
                }, 5000);
            }
            dispose() {
                this.textEl.remove();
                abdGroup.remove(this.mesh);
            }
        }

        function updateAbandoned() {
            const px = Math.floor(camera.position.x / abdChunkSize);
            const pz = Math.floor(camera.position.z / abdChunkSize);
            
            const neededKeys = [];
             for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    neededKeys.push(`${px + dx},${pz + dz}`);
                }
            }
            
            Object.keys(loadedAbdChunks).forEach(key => {
                if(!neededKeys.includes(key)) {
                    abdGroup.remove(loadedAbdChunks[key]);
                    delete loadedAbdChunks[key];
                }
            });
            
            neededKeys.forEach(key => {
                if(!loadedAbdChunks[key]) {
                    const [cx, cz] = key.split(',').map(Number);
                    const chunk = generateAbdChunk(cx, cz);
                    loadedAbdChunks[key] = chunk;
                    abdGroup.add(chunk);
                }
            });

            npcs.forEach(npc => npc.update());
        }

        function generateAbdChunk(cx, cz) {
            const group = new THREE.Group();
            const bx = cx * abdChunkSize;
            const bz = cz * abdChunkSize;
            
            const fl = new THREE.Mesh(new THREE.PlaneGeometry(abdChunkSize, abdChunkSize), new THREE.MeshStandardMaterial({color: 0x222222}));
            fl.rotation.x = -Math.PI/2;
            fl.position.set(bx + abdChunkSize/2, -15.1, bz + abdChunkSize/2);
            group.add(fl);

            const seed = pseudoRandom(cx, cz);
            const count = Math.floor(seed * 5) + 2; 

            for(let i=0; i<count; i++) {
                const h = 50 + pseudoRandom(bx+i, bz+i) * 150;
                const w = 10 + pseudoRandom(bx-i, bz-i) * 30;
                
                let col;
                if(settingMono) {
                    const shade = 0.2 + pseudoRandom(bx*i, bz) * 0.2; 
                    col = new THREE.Color(shade, shade, shade);
                } else {
                    col = new THREE.Color().setHSL(pseudoRandom(bx*i, bz), 0.5, 0.3);
                }

                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({color: col}));
                mesh.position.set(
                    bx + pseudoRandom(bx+i, i) * abdChunkSize,
                    h/2 - 20,
                    bz + pseudoRandom(bz+i, i) * abdChunkSize
                );
                group.add(mesh);
            }

            if(pseudoRandom(cx+0.5, cz+0.5) > 0.7) {
                 const npcX = bx + abdChunkSize/2;
                 const npcZ = bz + abdChunkSize/2;
                 const npc = new NPC(npcX, npcZ);
                 npcs.push(npc);
            }
            return group;
        }

        function updateCyberMovement() {
            if (!settingCyber) return;

            const speed = isSprinting ? 1.5 : 0.8;
            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            if (moveForward || joystickY < -0.2) direction.add(forward);
            if (moveBackward || joystickY > 0.2) direction.sub(forward);
            if (moveRight || joystickX > 0.2) direction.add(right);
            if (moveLeft || joystickX < -0.2) direction.sub(right);

            direction.normalize();

            let velX = 0, velZ = 0;
            if (direction.length() > 0) {
                velX = direction.x * speed;
                velZ = direction.z * speed;
            }

            if (inBackrooms) {
                const nextX = camera.position.x + velX * 2; 
                const nextZ = camera.position.z + velZ * 2;
                if (!checkCollision(nextX, camera.position.z)) {
                    playerVelocity.x = velX;
                } else { playerVelocity.x = 0; }
                
                if (!checkCollision(camera.position.x, nextZ)) {
                    playerVelocity.z = velZ;
                } else { playerVelocity.z = 0; }
            } else {
                playerVelocity.x = velX;
                playerVelocity.z = velZ;
            }

            playerVelocity.y -= 0.05; 
            camera.position.add(playerVelocity);

            let eyeHeight = isCrouching ? 5 : 10;
            const floorLevel = -15 + eyeHeight;

            if (camera.position.y < floorLevel) {
                playerVelocity.y = 0;
                camera.position.y = floorLevel;
                canJump = true;
            }

            if (flashOn) {
                flashLight.position.copy(camera.position);
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                flashLight.target.position.copy(camera.position).add(camDir);
                flashLight.intensity = document.getElementById('sl-flash-int').value;
            } else {
                flashLight.intensity = 0;
            }

            const compassArrow = document.getElementById('compass-arrow');
            const coordDiv = document.getElementById('coords');
            
            if (compassArrow) {
                if (inBackrooms || inAbandoned) {
                    const camY = camera.rotation.y;
                    const deg = THREE.MathUtils.radToDeg(-camY);
                    compassArrow.style.transform = `rotate(${deg}deg)`;
                } else {
                    const localPos = currentMesh.position.clone();
                    localPos.applyMatrix4(camera.matrixWorldInverse);
                    const angle = Math.atan2(localPos.x, -localPos.z);
                    const deg = THREE.MathUtils.radToDeg(angle);
                    compassArrow.style.transform = `rotate(${deg}deg)`;
                }
            }
            if (coordDiv) {
                coordDiv.innerText = `X: ${Math.round(camera.position.x)} Y: ${Math.round(camera.position.z)}`;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            drawCanvas();
            updateDominos();
            updatePhysics();
            updateCyberMovement();
            
            if(inBackrooms) updateBackrooms();
            if(inAbandoned) updateAbandoned();

            if (!settingCyber) {
                controls.enabled = !isDragging;
                controls.update();
                renderer.render(scene, camera);
            } else {
                controls.enabled = false;
                if (settingBloom) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
            }
        }

        initGrid();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        const uiWrapper = document.getElementById('ui-wrapper');
        const uiToggleBtn = document.getElementById('ui-toggle-btn');
        const btnAimToggle = document.getElementById('btn-aim-toggle');
        
        function toggleSettings() {
             uiWrapper.classList.toggle('open');
        }

        uiToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSettings();
        });
        
        document.addEventListener('click', (e) => {
             if (uiWrapper.classList.contains('open') && !uiWrapper.contains(e.target)) {
                 uiWrapper.classList.remove('open');
             }
        });

        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        function switchTab(targetId) {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            const activeTab = document.querySelector(`[data-target="${targetId}"]`);
            if(activeTab) activeTab.classList.add('active');
            const content = document.getElementById(targetId);
            if(content) content.classList.add('active');
        }
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => switchTab(tab.dataset.target));
        });

        function syncInput(sliderId, numId, callback) {
            const s = document.getElementById(sliderId);
            const n = document.getElementById(numId);
            s.addEventListener('input', () => { n.value = s.value; if(callback) callback(s.value); });
            n.addEventListener('input', () => { s.value = n.value; if(callback) callback(n.value); });
        }

        document.getElementById('btn-shape').addEventListener('click', (e) => {
            isSphere = !isSphere;
            const oldPos = currentMesh.position.clone();
            const oldRot = currentMesh.rotation.clone();
            const oldScale = currentMesh.scale.clone();
            scene.remove(currentMesh);
            currentMesh = new THREE.Mesh(isSphere ? geometrySphere : geometryBox, material);
            currentMesh.position.copy(oldPos);
            currentMesh.rotation.copy(oldRot);
            currentMesh.scale.copy(oldScale);
            currentMesh.castShadow = true;
            currentMesh.receiveShadow = true;
            scene.add(currentMesh);
            e.target.innerText = isSphere ? "Toggle Shape: Sphere" : "Toggle Shape: Cube";
        });
        document.getElementById('col-mesh').addEventListener('input', (e) => { meshColor = e.target.value; staticNeedsUpdate = true; });
        document.getElementById('col-grid').addEventListener('input', (e) => { gridColor = e.target.value; staticNeedsUpdate = true; });
        document.getElementById('chk-grid').addEventListener('change', (e) => { settingShowGrid = e.target.checked; staticNeedsUpdate = true; });
        
        syncInput('sl-grid-thick', 'num-grid-thick', (v) => { settingGridThick = parseFloat(v); staticNeedsUpdate = true; });

        document.getElementById('chk-chars').addEventListener('change', (e) => { settingShowChars = e.target.checked; });
        
        syncInput('sl-grid', 'num-grid', (v) => { updateGridSize(v); });
        
        function updateGridSize(val) {
            const v = parseInt(val);
            if (v < 2) return;
            rows = v;
            initGrid();
        }
        
        syncInput('sl-scale', 'num-scale', (v) => {
            const s = parseFloat(v);
            currentMesh.scale.set(s,s,s);
        });

        syncInput('sl-res', 'num-res', (v) => { renderer.setPixelRatio(window.devicePixelRatio * parseFloat(v)); });

        document.getElementById('col-sky').addEventListener('input', (e) => { 
            scene.background = new THREE.Color(e.target.value); 
            scene.fog.color = new THREE.Color(e.target.value);
        });
        
        syncInput('sl-luminance', 'num-luminance', (v) => { ambientLight.intensity = parseFloat(v); });
        document.getElementById('col-floor').addEventListener('input', (e) => { floorMesh.material.color.set(e.target.value); });

        const btnShuffle = document.getElementById('btn-shuffle');
        document.getElementById('chk-randomizer').addEventListener('change', (e) => { 
            settingRandomizer = e.target.checked;
            btnShuffle.disabled = settingRandomizer;
        });
        btnShuffle.addEventListener('click', () => {
             for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (!gridData[y][x].frozen) gridData[y][x].char = chars[Math.floor(Math.random() * chars.length)];
                }
            }
        });
        document.getElementById('chk-spread').addEventListener('change', (e) => { settingSpread = e.target.checked; });

        const mobileUi = document.getElementById('mobile-ui');
        const interactionUi = document.getElementById('interaction-ui');
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const cyberTabBtn = document.getElementById('tab-cyber-btn');
        const rowFloor = document.getElementById('row-floor');
        const rowGravity = document.getElementById('row-gravity');
        const cyberOverlay = document.getElementById('cyber-overlay');
        const crosshair = document.getElementById('crosshair');
        const hudLeft = document.getElementById('hud-top-left');
        const btnBackrooms = document.getElementById('btn-backrooms');
        
        let overlayTimeout;

        document.getElementById('chk-physics').addEventListener('change', (e) => { 
            settingPhysics = e.target.checked;
            floorMesh.visible = settingPhysics && !inBackrooms && !inAbandoned;
            
            if (settingPhysics) {
                rowFloor.classList.add('visible');
                rowGravity.classList.add('visible');
                cyberTabBtn.classList.add('visible');
                if(isMobile) interactionUi.style.display = 'flex';
            } else {
                rowFloor.classList.remove('visible');
                rowGravity.classList.remove('visible');
                cyberTabBtn.classList.remove('visible');
                if (document.getElementById('tab-cyber').classList.contains('active')) {
                    switchTab('tab-visual');
                }
                currentMesh.position.set(0,0,0);
                currentMesh.rotation.set(0,0,0);
                settingCyber = false;
                document.getElementById('chk-cyberspace').checked = false;
                exitCyberMode();
                if(isMobile) interactionUi.style.display = 'none';
            }
        });
        
        syncInput('sl-gravity', 'num-gravity', (v) => { settingGravity = parseFloat(v); });

        const chkCyber = document.getElementById('chk-cyberspace');
        chkCyber.addEventListener('change', (e) => {
            settingCyber = e.target.checked;
            if (settingCyber) {
                uiWrapper.classList.add('cyber-mode');
                uiWrapper.classList.remove('open'); 
                camera.position.y = -5;
                camera.lookAt(0, 0, 0);
                btnBackrooms.style.display = 'block';
                
                document.getElementById('sl-luminance').value = 1;
                document.getElementById('num-luminance').value = 1;
                ambientLight.intensity = 1;

                if (isMobile) {
                    mobileUi.style.display = 'block';
                } else {
                    cyberOverlay.style.display = 'block';
                    crosshair.style.display = 'block';
                    
                    cyberOverlay.style.opacity = '1';
                    if (overlayTimeout) clearTimeout(overlayTimeout);
                    overlayTimeout = setTimeout(() => {
                        cyberOverlay.style.opacity = '0';
                        setTimeout(() => { if(cyberOverlay.style.opacity === '0') cyberOverlay.style.display = 'none'; }, 1000);
                    }, 5000);
                }
                hudLeft.style.display = 'flex';
            } else {
                exitCyberMode();
            }
        });

        btnAimToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleAimLock();
        });

        function toggleAimLock() {
            if (!settingCyber || isMobile) return;
            aimLocked = !aimLocked;
            if (aimLocked) {
                document.body.requestPointerLock();
                btnAimToggle.classList.add('active');
            } else {
                document.exitPointerLock();
                btnAimToggle.classList.remove('active');
            }
        }
        document.addEventListener('pointerlockchange', () => {
             if(document.pointerLockElement !== document.body) {
                 aimLocked = false;
                 btnAimToggle.classList.remove('active');
             } else {
                 aimLocked = true;
                 btnAimToggle.classList.add('active');
             }
        });

        function exitCyberMode() {
            uiWrapper.classList.remove('cyber-mode');
            flashOn = false;
            flashLight.intensity = 0;
            mobileUi.style.display = 'none';
            cyberOverlay.style.display = 'none';
            crosshair.style.display = 'none';
            hudLeft.style.display = 'none';
            btnBackrooms.style.display = 'none';
            aimLocked = false;
            btnAimToggle.classList.remove('active');
            
            inBackrooms = false; inAbandoned = false;
            resetWorldState();

            if (document.pointerLockElement === document.body) document.exitPointerLock();
            camera.position.set(0, 0, 25);
            camera.lookAt(0, 0, 0);
            isHoldingDesktop = false;
            if(overlayTimeout) clearTimeout(overlayTimeout);
            camera.rotation.set(0,0,0);
        }

        function resetWorldState() {
             currentMesh.visible = true;
             floorMesh.visible = true;
             brGroup.visible = false;
             abdGroup.visible = false;
             btnBackrooms.innerText = "ENTER ROOMS";
             btnBackrooms.style.background = "#520";
             
             scene.fog.color.set(document.getElementById('col-sky').value);
             scene.background.set(document.getElementById('col-sky').value);
             ambientLight.intensity = 1;
             renderer.setPixelRatio(window.devicePixelRatio * parseFloat(document.getElementById('sl-res').value));
        }
        
        btnBackrooms.addEventListener('click', () => {
             toggleBackrooms();
        });

        function toggleBackrooms() {
            if(inAbandoned) {
                inAbandoned = false;
                enterBackrooms();
                return;
            }

            if(inBackrooms) {
                inBackrooms = false;
                resetWorldState();
            } else {
                enterBackrooms();
            }
        }

        function enterBackrooms() {
            inBackrooms = true;
            btnBackrooms.innerText = "LEAVE ROOMS";
            btnBackrooms.style.background = "#250";
            currentMesh.visible = false;
            floorMesh.visible = false;
            brGroup.visible = true;
            abdGroup.visible = false;
            
            ambientLight.intensity = 0.2;
            
            loadedChunks = {};
            while(brGroup.children.length > 0){ brGroup.remove(brGroup.children[0]); }
            interactables = [];
        }

        function enterAbandoned() {
            inBackrooms = false;
            inAbandoned = true;
            brGroup.visible = false;
            abdGroup.visible = true;
            
            scene.background.setHex(0x808080);
            scene.fog.color.setHex(0x808080);
            ambientLight.intensity = 0.35;
            renderer.setPixelRatio(window.devicePixelRatio * 0.5);
            
            loadedAbdChunks = {};
            while(abdGroup.children.length > 0){ abdGroup.remove(abdGroup.children[0]); }
            npcs = [];
            
            camera.position.y = -10; 
        }

        document.getElementById('col-flash').addEventListener('input', (e) => { flashLight.color.set(e.target.value); });
        syncInput('sl-flash-int', 'num-flash-int', null);
        syncInput('sl-flash-dist', 'num-flash-dist', (v) => { flashLight.distance = parseFloat(v); });
        syncInput('sl-flash-angle', 'num-flash-angle', (v) => { flashLight.angle = parseFloat(v); });
        
        document.getElementById('chk-bloom').addEventListener('change', (e) => {
            settingBloom = e.target.checked;
        });
        syncInput('sl-bloom', 'num-bloom', (v) => { bloomPass.strength = parseFloat(v); });
        
        document.getElementById('chk-mono').addEventListener('change', (e) => {
            settingMono = e.target.checked;
            loadedAbdChunks = {};
            abdGroup.clear();
            npcs = []; 
            interactables = interactables.filter(obj => !obj.userData.npc); 
        });
        
        syncInput('sl-view-dist', 'num-view-dist', (v) => { 
            camera.far = parseFloat(v); 
            scene.fog.far = parseFloat(v);
            camera.updateProjectionMatrix();
        });

        document.addEventListener('keydown', (e) => {
            if (!settingCyber) return;
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { playerVelocity.y = 1.0; canJump = false; } break;
                case 'ShiftLeft': isSprinting = true; break;
                case 'KeyC': isCrouching = true; break;
                case 'KeyF': flashOn = !flashOn; break;
                case 'AltLeft': 
                case 'AltRight':
                    e.preventDefault();
                    toggleAimLock(); 
                    break;
                case 'KeyT': 
                    if (isHoldingDesktop) {
                         releaseObject(2); 
                         isHoldingDesktop = false;
                    }
                    break;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (!settingCyber) return;
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSprinting = false; break;
                case 'KeyC': isCrouching = false; break;
            }
        });

        document.addEventListener('mousedown', (e) => {
            if (!settingCyber || isMobile || e.target.closest('#ui-wrapper')) return;

            if (e.button === 2) {
            }
            if (e.button === 0) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
                
                const interactHits = raycaster.intersectObjects(interactables, true); 
                if (interactHits.length > 0 && interactHits[0].distance < 20) {
                    const obj = interactHits[0].object;
                    let target = obj;
                    while(target.parent && !target.userData.type && !target.userData.npc) {
                        target = target.parent;
                    }

                    if (target.userData.type === 'door') {
                        enterAbandoned();
                        return;
                    }
                    if (target.userData.npc) {
                        target.userData.npc.interact();
                        return;
                    }
                }

                const intersects = raycaster.intersectObject(currentMesh);
                if (intersects.length > 0 && currentMesh.position.distanceTo(camera.position) < 25 && !inBackrooms && !inAbandoned) {
                    isHoldingDesktop = true;
                    holdDistance = currentMesh.position.distanceTo(camera.position);
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (!settingCyber || isMobile) return;
            if (e.button === 0) {
                isHoldingDesktop = false;
            }
        });
        
        document.addEventListener('wheel', (e) => {
            if (!settingCyber) return;
            if (isHoldingDesktop) {
                holdDistance -= e.deltaY * 0.01;
                if (holdDistance < 2) holdDistance = 2;
                if (holdDistance > 30) holdDistance = 30;
            }
        });

        document.addEventListener('contextmenu', (e) => { e.preventDefault(); });

        document.addEventListener('mousemove', (e) => {
            if (settingCyber && !isMobile) {
                if (aimLocked || (e.buttons & 2) === 2 || document.pointerLockElement === document.body) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            }
        });

        const joystickArea = document.getElementById('joystick-area');
        const joystickStick = document.getElementById('joystick-stick');
        let joystickX = 0, joystickY = 0, joystickTouchId = null;

        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joystickTouchId = touch.identifier;
            updateJoystick(touch.clientX, touch.clientY);
        });
        joystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i=0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystickTouchId) updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
            }
        });
        joystickArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickX = 0; joystickY = 0;
            joystickStick.style.transform = `translate(-50%, -50%)`;
        });
        function updateJoystick(x, y) {
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            let dx = x - centerX, dy = y - centerY;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 35);
            const angle = Math.atan2(dy, dx);
            joystickStick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
            joystickX = (Math.cos(angle)*dist) / 35;
            joystickY = (Math.sin(angle)*dist) / 35;
        }

        let touchStartDist = 0;
        document.addEventListener('touchstart', (e) => {
            if(!settingCyber || !isMobile) return;
            
            if (e.touches.length === 2 && isHoldingMobile) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx*dx + dy*dy);
            }

            if(e.target.closest('#mobile-buttons') || e.target.closest('#joystick-area') || e.target.closest('#ui-wrapper') || e.target.closest('#interaction-ui')) return;

            const touch = e.touches[0];
            if(touch.clientX > window.innerWidth / 2) {
                isLooking = true;
                lastLookX = touch.clientX;
                lastLookY = touch.clientY;
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if(!settingCyber || !isMobile) return;

            if (e.touches.length === 2 && isHoldingMobile) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const delta = dist - touchStartDist;
                holdDistance += delta * 0.05;
                if(holdDistance < 2) holdDistance = 2;
                if(holdDistance > 30) holdDistance = 30;
                touchStartDist = dist;
                return; 
            }

            if(!isLooking) return;
            const touch = e.touches[0];
            const deltaX = touch.clientX - lastLookX;
            const deltaY = touch.clientY - lastLookY;
            camera.rotation.y -= deltaX * 0.005;
            camera.rotation.x -= deltaY * 0.005;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            lastLookX = touch.clientX;
            lastLookY = touch.clientY;
        });

        document.addEventListener('touchend', () => { isLooking = false; });

        document.getElementById('m-sprint').addEventListener('touchstart', (e)=>{ e.preventDefault(); isSprinting=true; });
        document.getElementById('m-sprint').addEventListener('touchend', (e)=>{ e.preventDefault(); isSprinting=false; });
        document.getElementById('m-jump').addEventListener('touchstart', (e)=>{ e.preventDefault(); if(canJump){playerVelocity.y=1.0; canJump=false;} });
        document.getElementById('m-crouch').addEventListener('touchstart', (e)=>{ e.preventDefault(); isCrouching=true; });
        document.getElementById('m-crouch').addEventListener('touchend', (e)=>{ e.preventDefault(); isCrouching=false; });
        document.getElementById('m-flash').addEventListener('touchstart', (e)=>{ e.preventDefault(); flashOn=!flashOn; });

        const btnGrab = document.getElementById('m-grab');
        const btnDrop = document.getElementById('m-drop');
        const btnThrow = document.getElementById('m-throw');

        btnGrab.addEventListener('touchstart', (e) => {
            e.preventDefault();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
            const intersects = raycaster.intersectObject(currentMesh);
            if (currentMesh.position.distanceTo(camera.position) < 25 && !inBackrooms && !inAbandoned) {
                isHoldingMobile = true;
                holdDistance = currentMesh.position.distanceTo(camera.position);
                btnGrab.style.display = 'none';
                btnDrop.style.display = 'flex';
                btnThrow.style.display = 'flex';
            }
        });

        btnDrop.addEventListener('touchstart', (e) => { e.preventDefault(); releaseObject(0); });
        btnThrow.addEventListener('touchstart', (e) => { e.preventDefault(); releaseObject(2); });

        function releaseObject(power) {
            isHoldingMobile = false;
            btnGrab.style.display = 'flex';
            btnDrop.style.display = 'none';
            btnThrow.style.display = 'none';
            if (power > 0) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                objVelocity.copy(forward).multiplyScalar(power);
                objVelocity.y += 0.5; 
            }
        }

        window.addEventListener('pointerdown', (event) => {
            if (event.target.closest('#ui-wrapper') || event.target.closest('#mobile-ui') || settingCyber) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentMesh);
            if (intersects.length > 0) {
                if (settingPhysics) {
                    isDragging = true;
                    controls.enabled = false;
                    dragPlane.normal.copy(camera.position).normalize();
                    dragPlane.constant = -currentMesh.position.dot(dragPlane.normal);
                    raycasterPlane.setFromCamera(mouse, camera);
                    const planeIntersect = new THREE.Vector3();
                    raycasterPlane.ray.intersectPlane(dragPlane, planeIntersect);
                    previousDragPosition.copy(planeIntersect);
                } else {
                    const uv = intersects[0].uv;
                    let col = Math.floor(uv.x * cols);
                    let row = Math.floor((1 - uv.y) * rows);
                    if (col >= cols) col = cols - 1; if (row >= rows) row = rows - 1;
                    if (row >= 0 && row < rows && col >= 0 && col < cols) {
                        if (settingSpread) {
                            const cell = gridData[row][col];
                            const newState = !cell.frozen;
                            activeWaveState = newState;
                            cell.frozen = newState;
                            if (newState) cell.frozenChar = cell.char;
                        } else {
                            const isPaused = gridData[0][0].frozen; 
                            const newState = !isPaused;
                            for (let y = 0; y < rows; y++) {
                                for (let x = 0; x < cols; x++) {
                                    gridData[y][x].frozen = newState;
                                    if (newState) gridData[y][x].frozenChar = gridData[y][x].char;
                                }
                            }
                        }
                    }
                }
            }
        });
        window.addEventListener('pointermove', (event) => {
            if (isDragging && settingPhysics && !settingCyber) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycasterPlane.setFromCamera(mouse, camera);
                const planeIntersect = new THREE.Vector3();
                raycasterPlane.ray.intersectPlane(dragPlane, planeIntersect);
                if (planeIntersect) {
                    const delta = new THREE.Vector3().subVectors(planeIntersect, previousDragPosition);
                    currentMesh.position.add(delta);
                    objVelocity.copy(delta);
                    previousDragPosition.copy(planeIntersect);
                }
            }
        });
        window.addEventListener('pointerup', () => {
            if (isDragging) { isDragging = false; controls.enabled = true; objVelocity.multiplyScalar(2); }
        });
    </script>
</body>
</html>
