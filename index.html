<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Orb.exe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: black; font-family: 'Monospace', monospace; touch-action: none; }
        canvas { display: block; }
        
        #ui-wrapper {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        #ui-header {
            background: #222;
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border: 1px solid #444;
            user-select: none;
        }

        #ui-wrapper.cyber-mode #ui-header {
            background: transparent;
            border: none;
            padding: 0;
            justify-content: flex-end;
            pointer-events: none;
            gap: 10px;
        }
        
        #ui-wrapper.cyber-mode #ui-header span {
            display: none;
        }

        .header-btn {
            background: #222;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            padding: 5px 12px;
            cursor: pointer;
            pointer-events: auto;
            font-weight: bold;
            font-family: inherit;
        }
        .header-btn:hover { background: #444; }
        .header-btn.active { background: #00aa00; border-color: #0f0; }

        #btn-aim-toggle { display: none; }
        #ui-wrapper.cyber-mode #btn-aim-toggle { display: block; }

        #ui-content {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, border 0.3s;
            border: none; 
        }

        #ui-wrapper.open #ui-content {
            max-height: 80vh;
            border: 1px solid #444; 
            border-top: none;
        }
        
        #ui-wrapper.cyber-mode.open #ui-header {
             pointer-events: auto; 
        }

        .tabs {
            display: flex;
            background: #1a1a1a;
            border-bottom: 1px solid #444;
        }

        .tab {
            flex: 1;
            padding: 10px 0;
            text-align: center;
            cursor: pointer;
            font-size: 10px;
            color: #888;
            background: #1a1a1a;
            border: none;
            font-family: 'Monospace', monospace;
        }

        .tab.active {
            color: white;
            background: #333;
            font-weight: bold;
        }

        .tab-content {
            padding: 15px;
            display: none;
            overflow-y: auto;
            max-height: 60vh;
        }

        .tab-content.active { display: block; }

        .row { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 12px; 
            flex-wrap: wrap;
        }
        
        .label { font-size: 12px; font-weight: bold; color: #ccc; }
        
        button.action-btn {
            background: #333; color: white; border: 1px solid #666; 
            padding: 6px 10px; cursor: pointer; font-family: inherit; width: 100%;
            border-radius: 4px;
            margin-top: 5px;
            font-family: 'Monospace', monospace;
        }
        button.action-btn:hover { background: #555; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        input[type="color"] { border: none; width: 30px; height: 30px; padding: 0; background: none; cursor: pointer; }
        input[type="range"] { flex-grow: 1; margin: 0 10px; cursor: pointer; }
        input[type="number"] { width: 60px; background: #222; border: 1px solid #555; color: white; padding: 2px; font-family: 'Monospace', monospace; margin-left: 5px; }
        input[type="checkbox"] { transform: scale(1.2); cursor: pointer; }

        #tab-cyber-btn { display: none; }
        #tab-cyber-btn.visible { display: block; }
        .secret-setting { display: none; }
        .secret-setting.visible { display: flex; }

        #cyber-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 15px 25px;
            border: 1px solid #444;
            display: none;
            pointer-events: none;
            user-select: none;
            text-align: center;
            line-height: 1.6;
            opacity: 1;
            transition: opacity 1s ease-out; 
            z-index: 60;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            mix-blend-mode: difference;
            z-index: 50;
        }

        #hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            display: none;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            z-index: 90;
            pointer-events: auto;
        }

        #compass {
            width: 60px;
            height: 60px;
            border: 2px solid #555;
            border-radius: 50%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }

        #compass-arrow {
            color: #ff3333;
            font-size: 24px;
            font-weight: bold;
            transform-origin: center;
            display: block;
        }

        #coords {
            color: #ffffff;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border: 1px solid #444;
            font-size: 12px;
            font-family: monospace;
            cursor: pointer;
            user-select: none;
        }
        
        #time-display {
             color: white;
             font-size: 12px;
             margin-top: 5px;
             font-family: monospace;
             text-shadow: 1px 1px 0 #000;
             display: none;
             cursor: pointer;
             mix-blend-mode: difference;
             font-weight: bold;
        }

        #npc-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 80;
        }

        .npc-dialogue {
            position: absolute;
            background: white;
            color: black;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            opacity: 0.9;
            font-weight: bold;
            display: none;
        }
        .npc-dialogue::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: white transparent transparent transparent;
        }

        #mobile-ui {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        #joystick-area {
            position: absolute;
            bottom: 40px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystick-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #mobile-buttons {
            position: absolute;
            bottom: 30px;
            right: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            pointer-events: auto;
        }

        .mob-btn {
            width: 65px;
            height: 65px;
            background: rgba(50, 50, 50, 0.7);
            border: 1px solid #888;
            border-radius: 50%;
            color: white;
            font-size: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            cursor: pointer;
        }
        .mob-btn:active { background: rgba(100, 100, 100, 0.9); }

        #interaction-ui {
            display: none;
            position: absolute;
            bottom: 180px;
            right: 20px;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            z-index: 51;
        }
        
        .interact-btn {
            width: 80px;
            height: 40px;
            background: rgba(0, 100, 200, 0.6);
            border: 1px solid #8cf;
            color: white;
            font-weight: bold;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        .interact-btn.throw { background: rgba(200, 50, 50, 0.6); border-color: #f88; }
        .interact-btn.drop { background: rgba(100, 100, 100, 0.6); border-color: #ccc; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #222; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="hud-top-left">
        <div id="compass"><span id="compass-arrow">▲</span></div>
        <div id="coords">X: 0 Y: 0</div>
        <div id="time-display">12:00 PM</div>
    </div>
    
    <div id="npc-container"></div>

    <div id="cyber-overlay">
        HOLD [R-CLICK] OR TOGGLE [ALT/⊕] TO LOOK<br>
        HOLD [L-CLICK] TO GRAB | SCROLL TO PUSH/PULL<br>
        [T] THROW | [C] CROUCH | [SHIFT] SPRINT<br>
        WASD TO MOVE
    </div>

    <div id="ui-wrapper">
        <div id="ui-header">
            <span>Settings</span>
            <button id="btn-aim-toggle" class="header-btn" title="Toggle Aim Lock (Alt)">⊕</button>
            <button id="ui-toggle-btn" class="header-btn">•••</button>
        </div>
        <div id="ui-content">
            <div class="tabs">
                <button class="tab active" data-target="tab-visual" id="btn-tab-visual">Visual</button>
                <button class="tab" data-target="tab-world">World</button>
                <button class="tab" data-target="tab-behavior">Logic</button>
                <button class="tab" data-target="tab-physics">Physics</button>
                <button class="tab" id="tab-cyber-btn" data-target="tab-cyber">Cyber</button>
            </div>

            <div id="tab-visual" class="tab-content active">
                <div class="row">
                    <button class="action-btn" id="btn-shape">Toggle Shape: Sphere</button>
                </div>
                <div class="row">
                    <span class="label">Mesh Color</span>
                    <input type="color" id="col-mesh" value="#ffffff">
                </div>
                <div class="row">
                    <span class="label">Grid Color</span>
                    <input type="color" id="col-grid" value="#000000">
                </div>
                <div class="row">
                    <span class="label">Display Grid</span>
                    <input type="checkbox" id="chk-grid" checked>
                </div>
                <div class="row">
                    <span class="label">Grid Thickness</span>
                    <input type="range" id="sl-grid-thick" min="1" max="10" step="0.5" value="2">
                    <input type="number" id="num-grid-thick" value="2">
                </div>
                <div class="row">
                    <span class="label">Display Chars</span>
                    <input type="checkbox" id="chk-chars" checked>
                </div>
                <div class="row">
                    <span class="label">Grid Density</span>
                    <input type="range" id="sl-grid" min="10" max="100" value="20">
                    <input type="number" id="num-grid" value="20">
                </div>
                <div class="row">
                    <span class="label">Object Size</span>
                    <input type="range" id="sl-scale" min="0.1" max="3" step="0.1" value="1">
                    <input type="number" id="num-scale" value="1">
                </div>
            </div>

            <div id="tab-world" class="tab-content">
                <div class="row">
                    <span class="label">Sky Color</span>
                    <input type="color" id="col-sky" value="#000000">
                </div>
                <div class="row">
                    <span class="label">Sky Luminance</span>
                    <input type="range" id="sl-luminance" min="0" max="3" step="0.1" value="1">
                    <input type="number" id="num-luminance" value="1">
                </div>
                <div class="row secret-setting" id="row-floor">
                    <span class="label">Floor Color (Physics)</span>
                    <input type="color" id="col-floor" value="#222222">
                </div>
            </div>

            <div id="tab-behavior" class="tab-content">
                <div class="row">
                    <span class="label">Randomizer</span>
                    <input type="checkbox" id="chk-randomizer" checked>
                </div>
                <div class="row">
                    <button class="action-btn" id="btn-shuffle" disabled>Manual Shuffle</button>
                </div>
                <div class="row">
                    <span class="label">Spread Effect</span>
                    <input type="checkbox" id="chk-spread" checked>
                </div>
                <div class="row">
                    <span class="label">Resolution</span>
                    <input type="range" id="sl-res" min="0.1" max="1" step="0.1" value="1">
                    <input type="number" id="num-res" value="1">
                </div>
            </div>

            <div id="tab-physics" class="tab-content">
                <div class="row">
                    <span class="label">Enable Physics</span>
                    <input type="checkbox" id="chk-physics">
                </div>
                <div class="row secret-setting" id="row-gravity">
                    <span class="label">Gravity</span>
                    <input type="range" id="sl-gravity" min="0" max="2" step="0.05" value="0.5">
                    <input type="number" id="num-gravity" value="0.5">
                </div>
            </div>

            <div id="tab-cyber" class="tab-content">
                <div class="row">
                    <span class="label">Cyberspace Mode</span>
                    <input type="checkbox" id="chk-cyberspace">
                </div>
                <div class="row" style="margin-top:10px;">
                     <button class="action-btn" id="btn-backrooms" style="background:#520; display:none;">ENTER ROOMS</button>
                </div>
                
                <div class="row" style="margin-top:10px; border-bottom:1px solid #333; padding-bottom:5px;">
                    <span class="label" style="color:white;">View Settings</span>
                </div>
                <div class="row">
                    <span class="label">Enable Bloom</span>
                    <input type="checkbox" id="chk-bloom" checked>
                </div>
                <div class="row bloom-setting">
                    <span class="label">Bloom Strength</span>
                    <input type="range" id="sl-bloom" min="0" max="3" step="0.1" value="0.4">
                    <input type="number" id="num-bloom" value="0.4">
                </div>
                 <div class="row">
                    <span class="label">View Distance</span>
                    <input type="range" id="sl-view-dist" min="10" max="2000" step="10" value="100">
                    <input type="number" id="num-view-dist" value="100">
                </div>

                <div class="row" style="margin-top:10px; border-bottom:1px solid #333; padding-bottom:5px;">
                    <span class="label" style="color:white;">Zone Settings</span>
                </div>
                <div class="row">
                    <span class="label">Mono NPCs/Buildings</span>
                    <input type="checkbox" id="chk-mono" checked>
                </div>
                <div class="row">
                    <span class="label">NPC Spawn Rate</span>
                    <input type="range" id="sl-npc-rate" min="0.1" max="1" step="0.1" value="0.6">
                    <input type="number" id="num-npc-rate" value="0.6">
                </div>

                <div class="row" style="margin-top:10px; border-bottom:1px solid #333; padding-bottom:5px;">
                    <span class="label" style="color:white;">Flashlight Settings</span>
                </div>
                <div class="row">
                    <span class="label">Color</span>
                    <input type="color" id="col-flash" value="#ffffff">
                </div>
                <div class="row">
                    <span class="label">Brightness</span>
                    <input type="range" id="sl-flash-int" min="0" max="5" step="0.1" value="4">
                    <input type="number" id="num-flash-int" value="4">
                </div>
                <div class="row">
                    <span class="label">Distance</span>
                    <input type="range" id="sl-flash-dist" min="10" max="200" value="50">
                    <input type="number" id="num-flash-dist" value="50">
                </div>
                 <div class="row">
                    <span class="label">Size (Angle)</span>
                    <input type="range" id="sl-flash-angle" min="0.1" max="1.5" step="0.1" value="0.5">
                    <input type="number" id="num-flash-angle" value="0.5">
                </div>
            </div>
        </div>
    </div>

    <div id="mobile-ui">
        <div id="joystick-area">
            <div id="joystick-stick"></div>
        </div>
        <div id="mobile-buttons">
            <div class="mob-btn" id="m-sprint">SPRINT</div>
            <div class="mob-btn" id="m-jump">JUMP</div>
            <div class="mob-btn" id="m-crouch">CROUCH</div>
            <div class="mob-btn" id="m-flash">LIGHT</div>
        </div>
        <div id="interaction-ui">
            <div class="interact-btn" id="m-grab">GRAB</div>
            <div class="interact-btn drop" id="m-drop" style="display:none;">LET GO</div>
            <div class="interact-btn throw" id="m-throw" style="display:none;">THROW</div>
        </div>
    </div>

    <script src="js/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="js/OrbitControls.js"></script>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 20, 100); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000); 
        camera.position.z = 25;
        camera.rotation.order = 'YXZ'; 

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.shadowMap.enabled = false; 
        document.body.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 0.4;
        bloomPass.radius = 0;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 12;
        controls.maxDistance = 60;

        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        const flashLight = new THREE.SpotLight(0xffffff, 0);
        flashLight.position.set(0, 0, 0);
        flashLight.angle = Math.PI / 6;
        flashLight.penumbra = 0.5;
        flashLight.decay = 2;
        flashLight.distance = 50;
        flashLight.target.position.set(0, 0, -1);
        scene.add(flashLight);
        scene.add(flashLight.target);

        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
        let rows = 20;
        let cols = 40;
        const canvasWidth = 1024; 
        const canvasHeight = 512;
        let gridData = [];
        let meshColor = '#ffffff';
        let gridColor = '#000000';
        let activeWaveState = null; 
        
        let settingRandomizer = true;
        let settingSpread = true;
        let settingPhysics = false;
        let settingShowGrid = true;
        let settingShowChars = true;
        let settingGravity = 0.5;
        let settingGridThick = 2;
        
        let settingCyber = false;
        let flashOn = false;
        let inBackrooms = false;
        let inAbandoned = false;
        let aimLocked = false;
        let settingBloom = true;
        let settingMono = true;
        let settingNpcRate = 0.6;
        
        const floorGeometry = new THREE.PlaneGeometry(300, 300);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
        const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = -15;
        floorMesh.visible = false;
        scene.add(floorMesh);

        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = canvasWidth;
        textureCanvas.height = canvasHeight;
        const ctx = textureCanvas.getContext('2d', { alpha: false });

        const staticCanvas = document.createElement('canvas');
        staticCanvas.width = canvasWidth;
        staticCanvas.height = canvasHeight;
        const staticCtx = staticCanvas.getContext('2d', { alpha: false });
        let staticNeedsUpdate = true;

        const texture = new THREE.CanvasTexture(textureCanvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        let geometrySphere = new THREE.SphereGeometry(10, 24, 24); 
        let geometryBox = new THREE.BoxGeometry(14, 14, 14);
        
        const material = new THREE.MeshLambertMaterial({ 
            map: texture
        });
        
        let currentMesh = new THREE.Mesh(geometrySphere, material);
        scene.add(currentMesh);

        let isSphere = true;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const raycasterPlane = new THREE.Raycaster();

        let objVelocity = new THREE.Vector3(0, 0, 0);
        let isDragging = false;
        let previousDragPosition = new THREE.Vector3();
        
        let isHoldingMobile = false;
        let isHoldingDesktop = false;
        let holdDistance = 15;
        
        let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false, isSprinting = false, isCrouching = false;

        let isLooking = false;
        let lastLookX = 0;
        let lastLookY = 0;

        const brGroup = new THREE.Group();
        scene.add(brGroup);
        const abdGroup = new THREE.Group();
        scene.add(abdGroup);

        const brWallGeo = new THREE.BoxGeometry(10, 20, 10);
        const noiseCanvas = document.createElement('canvas');
        noiseCanvas.width = 64; noiseCanvas.height = 64; 
        const nCtx = noiseCanvas.getContext('2d');
        nCtx.fillStyle = '#C2B280'; nCtx.fillRect(0,0,64,64);
        for(let i=0; i<500; i++) {
            nCtx.fillStyle = Math.random() > 0.5 ? 'rgba(0,0,0,0.06)' : 'rgba(255,255,255,0.06)';
            nCtx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
        }
        const wallTex = new THREE.CanvasTexture(noiseCanvas);
        const brWallMat = new THREE.MeshLambertMaterial({map: wallTex});
        
        const tileCanvas = document.createElement('canvas');
        tileCanvas.width = 64; tileCanvas.height = 64; 
        const tCtx = tileCanvas.getContext('2d');
        tCtx.fillStyle = '#A6A68C'; tCtx.fillRect(0,0,64,64);
        tCtx.strokeStyle = 'rgba(0,0,0,0.15)'; tCtx.lineWidth = 2; tCtx.strokeRect(0,0,64,64); 
        const ceilTex = new THREE.CanvasTexture(tileCanvas);
        const brCeilMat = new THREE.MeshLambertMaterial({map: ceilTex});

        const brFloorMat = new THREE.MeshLambertMaterial({color: 0x554433}); 
        const brLightMat = new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide});
        const brLightGeo = new THREE.PlaneGeometry(2, 8);

        const doorCanvas = document.createElement('canvas');
        doorCanvas.width = 64; doorCanvas.height = 128;
        const dCtx = doorCanvas.getContext('2d');
        dCtx.fillStyle = '#443322'; dCtx.fillRect(0,0,64,128);
        dCtx.strokeStyle = '#221100'; dCtx.lineWidth = 2; dCtx.beginPath();
        dCtx.arc(32, 64, 20, 0, Math.PI*2); dCtx.stroke();
        dCtx.strokeRect(5,5,54,118);
        const doorTex = new THREE.CanvasTexture(doorCanvas);
        const brDoorGeo = new THREE.BoxGeometry(6, 16, 11);
        const brDoorMat = new THREE.MeshLambertMaterial({map: doorTex});

        const abdChunkSize = 200; 
        const brChunkSize = 6; 
        const brTileSize = 14; 
        let loadedChunks = {};
        let loadedAbdChunks = {};
        let interactables = [];
        let npcs = [];
        let debris = [];
        let rainSystem = null;

        const dayCycleDuration = 300; 
        let dayTime = 0;
        let rainTimer = 0;
        let isRaining = false;
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 0);
        scene.add(sunLight);
        scene.add(sunLight.target);
        
        const moonGeo = new THREE.SphereGeometry(20, 8, 8);
        const moonMat = new THREE.MeshBasicMaterial({color: 0xffffaa});
        const moonMesh = new THREE.Mesh(moonGeo, moonMat);
        scene.add(moonMesh);
        moonMesh.visible = false;
        
        const starsGeo = new THREE.BufferGeometry();
        const starCount = 500;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random()-0.5) * 1000;
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starsMat = new THREE.PointsMaterial({color:0xffffff, size: 1.5, sizeAttenuation:false});
        const starSystem = new THREE.Points(starsGeo, starsMat);
        scene.add(starSystem);
        starSystem.visible = false;

        function initGrid() {
            cols = rows * 2; 
            gridData = [];
            for (let y = 0; y < rows; y++) {
                const row = [];
                for (let x = 0; x < cols; x++) {
                    row.push({
                        char: chars[Math.floor(Math.random() * chars.length)],
                        frozen: false,
                        frozenChar: ''
                    });
                }
                gridData.push(row);
            }
            staticNeedsUpdate = true;
        }

        function updateStaticLayer() {
            const cellWidth = canvasWidth / cols;
            const cellHeight = canvasHeight / rows;

            staticCtx.fillStyle = meshColor;
            staticCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (settingShowGrid) {
                staticCtx.lineWidth = settingGridThick; 
                staticCtx.strokeStyle = gridColor;
                staticCtx.beginPath();
                for (let i = 0; i <= cols; i++) {
                    const x = Math.floor(i * cellWidth);
                    staticCtx.moveTo(x, 0);
                    staticCtx.lineTo(x, canvasHeight);
                }
                for (let i = 0; i <= rows; i++) {
                    const y = Math.floor(i * cellHeight);
                    staticCtx.moveTo(0, y);
                    staticCtx.lineTo(canvasWidth, y);
                }
                staticCtx.stroke();
            }
            staticNeedsUpdate = false;
        }

        function drawCanvas() {
            if (staticNeedsUpdate) updateStaticLayer();
            ctx.drawImage(staticCanvas, 0, 0);

            if (settingShowChars) {
                const cellWidth = canvasWidth / cols;
                const cellHeight = canvasHeight / rows;

                ctx.fillStyle = gridColor;
                ctx.font = `bold ${Math.floor(cellHeight * 0.7)}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const cell = gridData[y][x];
                        if (!cell.frozen && settingRandomizer) {
                            if (Math.random() > 0.1) cell.char = chars[Math.floor(Math.random() * chars.length)];
                        } else if (cell.frozen) {
                            cell.char = cell.frozenChar;
                        }
                        const posX = (x * cellWidth) + (cellWidth / 2);
                        const posY = (y * cellHeight) + (cellHeight / 2);
                        ctx.fillText(cell.char, posX, posY);
                    }
                }
            }
            texture.needsUpdate = true;
        }

        let frameCount = 0;
        function updateDominos() {
            if (!settingSpread || activeWaveState === null || frameCount % 4 !== 0) return;
            const cellsToFlip = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (gridData[y][x].frozen === activeWaveState) {
                        const neighbors = [{r:y-1,c:x}, {r:y+1,c:x}, {r:y,c:x-1}, {r:y,c:x+1}];
                        neighbors.forEach(n => {
                            let nr = n.r, nc = n.c;
                            if (nc < 0) nc = cols - 1; if (nc >= cols) nc = 0;
                            if (nr >= 0 && nr < rows) {
                                if (gridData[nr][nc].frozen !== activeWaveState) {
                                    cellsToFlip.push({ r: nr, c: nc, char: gridData[y][x].frozenChar });
                                }
                            }
                        });
                    }
                }
            }
            cellsToFlip.forEach(item => {
                const cell = gridData[item.r][item.c];
                cell.frozen = activeWaveState;
                if (activeWaveState === true) cell.frozenChar = item.char;
            });
        }

        function updatePhysics() {
            if (!settingPhysics) {
                currentMesh.position.set(0,0,0);
                currentMesh.rotation.set(0,0,0);
                objVelocity.set(0,0,0);
                return;
            }

            if(settingPhysics && !inBackrooms && !inAbandoned) {
                floorMesh.position.x = camera.position.x;
                floorMesh.position.z = camera.position.z;
            }

            if (isDragging) return;

            if (isHoldingMobile || isHoldingDesktop) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                const targetPos = camera.position.clone().add(forward.multiplyScalar(holdDistance));
                currentMesh.position.lerp(targetPos, 0.1);
                objVelocity.set(0,0,0);
                currentMesh.rotation.x += 0.01;
                currentMesh.rotation.y += 0.01;
                return;
            }

            objVelocity.y -= settingGravity * 0.1;
            objVelocity.x *= 0.98; 
            objVelocity.z *= 0.98;

            currentMesh.position.add(objVelocity);
            currentMesh.rotation.x += objVelocity.z * 0.05;
            currentMesh.rotation.z -= objVelocity.x * 0.05;

            const floorY = -15;
            const radius = (isSphere ? 10 : 9) * currentMesh.scale.y; 

            if (currentMesh.position.y - radius < floorY) {
                currentMesh.position.y = floorY + radius;
                objVelocity.y *= -0.7; 
                if (Math.abs(objVelocity.y) < 0.1) objVelocity.y = 0;
                objVelocity.x *= 0.7;
                objVelocity.z *= 0.7;
            }
        }

        function pseudoRandom(x, y) {
            return Math.abs(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453) % 1;
        }
        
        function getTerrainHeight(x, z) {
            let h = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 10;
            h += Math.sin(x * 0.01 + z*0.02) * 20;
            return h - 15;
        }

        function updateBackrooms() {
            const cx = Math.floor(camera.position.x / (brChunkSize * brTileSize));
            const cz = Math.floor(camera.position.z / (brChunkSize * brTileSize));
            const viewDist = 2; 

            const neededKeys = [];
            for (let dx = -viewDist; dx <= viewDist; dx++) {
                for (let dz = -viewDist; dz <= viewDist; dz++) {
                    neededKeys.push(`${cx + dx},${cz + dz}`);
                }
            }

            Object.keys(loadedChunks).forEach(key => {
                if (!neededKeys.includes(key)) {
                    const chunk = loadedChunks[key];
                    chunk.traverse(c => {
                        if(c.geometry) c.geometry.dispose();
                    });
                    brGroup.remove(chunk);
                    interactables = interactables.filter(obj => !chunk.children.includes(obj));
                    delete loadedChunks[key];
                }
            });

            neededKeys.forEach(key => {
                if (!loadedChunks[key]) {
                    const [kx, kz] = key.split(',').map(Number);
                    const chunkMesh = generateChunk(kx, kz);
                    loadedChunks[key] = chunkMesh;
                    brGroup.add(chunkMesh);
                }
            });
        }

        function generateChunk(cx, cz) {
            const meshGroup = new THREE.Group();
            const wallGeoms = [];
            const floorGeoms = [];
            const ceilGeoms = [];
            
            for(let x=0; x<brChunkSize; x++) {
                for(let z=0; z<brChunkSize; z++) {
                    const wx = (cx * brChunkSize + x);
                    const wz = (cz * brChunkSize + z);
                    const rand = pseudoRandom(wx, wz);
                    
                    const posX = wx * brTileSize;
                    const posZ = wz * brTileSize;
                    
                    const flGeo = new THREE.PlaneGeometry(brTileSize, brTileSize);
                    flGeo.rotateX(-Math.PI/2);
                    flGeo.translate(posX, -15, posZ);
                    floorGeoms.push(flGeo);
                    
                    const clGeo = new THREE.PlaneGeometry(brTileSize, brTileSize);
                    clGeo.rotateX(Math.PI/2);
                    clGeo.translate(posX, 10, posZ); 
                    ceilGeoms.push(clGeo);

                    if (pseudoRandom(wx+0.1, wz+0.1) > 0.8) {
                        const light = new THREE.Mesh(brLightGeo, brLightMat);
                        light.rotation.x = Math.PI/2;
                        light.position.set(posX, 9.9, posZ);
                        meshGroup.add(light);
                    }

                    if (rand > 0.7) {
                        if (rand > 0.96) { 
                            const door = new THREE.Mesh(brDoorGeo, brDoorMat);
                            if (pseudoRandom(wx, wz+0.5) > 0.5) door.rotation.y = Math.PI/2;
                            door.position.set(posX, -6, posZ);
                            door.userData = { type: 'door' };
                            meshGroup.add(door);
                            interactables.push(door);
                        } else {
                            const wGeo = brWallGeo.clone();
                            wGeo.translate(posX, -5, posZ);
                            wallGeoms.push(wGeo);
                        }
                    }
                }
            }
            
            if(wallGeoms.length > 0) {
                const mergedWall = THREE.BufferGeometryUtils.mergeBufferGeometries(wallGeoms);
                const wallMesh = new THREE.Mesh(mergedWall, brWallMat);
                meshGroup.add(wallMesh);
            }
            if(floorGeoms.length > 0) {
                const mergedFloor = THREE.BufferGeometryUtils.mergeBufferGeometries(floorGeoms);
                const floorMesh = new THREE.Mesh(mergedFloor, brFloorMat);
                meshGroup.add(floorMesh);
            }
            if(ceilGeoms.length > 0) {
                const mergedCeil = THREE.BufferGeometryUtils.mergeBufferGeometries(ceilGeoms);
                const ceilMesh = new THREE.Mesh(mergedCeil, brCeilMat);
                meshGroup.add(ceilMesh);
            }
            
            return meshGroup;
        }

        function checkCollision(x, z) {
            if(!inBackrooms) return false;
            const gridX = Math.round(x / brTileSize);
            const gridZ = Math.round(z / brTileSize);
            const rand = pseudoRandom(gridX, gridZ);
            return rand > 0.7 && rand <= 0.96; 
        }
        
        class NPC {
            constructor(x, z) {
                const group = new THREE.Group();
                const col = settingMono ? new THREE.Color(0xffffff) : new THREE.Color().setHSL(Math.random(), 0.7, 0.5);
                const mat = new THREE.MeshLambertMaterial({color: col, emissive: col, emissiveIntensity: 1});
                const cone = new THREE.Mesh(new THREE.ConeGeometry(3, 8, 8), mat);
                cone.position.y = 4; 
                const head = new THREE.Mesh(new THREE.SphereGeometry(2, 8, 8), mat);
                head.position.y = 9;
                group.add(cone); group.add(head);
                
                const y = getTerrainHeight(x, z);
                group.position.set(x, y, z);
                
                this.mesh = group;
                this.vel = new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize().multiplyScalar(0.15);
                this.timer = 0;
                this.isPaused = false;
                
                this.textEl = document.createElement('div');
                this.textEl.className = 'npc-dialogue';
                const phrases = [
                    "Hello, are you lost too?", "I have been roaming this land for so long.", "I want to go home.", "Hi there.", "...", 
                    "I can't remember my name.", "I lost something here.", "I lost someone here.", "I saw a way out...", "Is this real?", 
                    "The noise...", "Don't look up.", "It never ends.", "I miss the sun.", "Who are you?", "System failure.", "Lost connection."
                ];
                this.textEl.innerText = phrases[Math.floor(Math.random()*phrases.length)];
                document.getElementById('npc-container').appendChild(this.textEl);
                this.mesh.userData = { npc: this };
                interactables.push(this.mesh.children[0]); 
                interactables.push(this.mesh.children[1]);
                abdGroup.add(group);
            }
            update() {
                if(!this.isPaused) {
                    this.timer++;
                    if(this.timer > 200) {
                        this.vel.set(Math.random()-0.5, 0, Math.random()-0.5).normalize().multiplyScalar(0.15);
                        this.timer = 0;
                    }
                    this.mesh.position.add(this.vel);
                    this.mesh.position.y = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
                }
                
                const pos = this.mesh.position.clone().add(new THREE.Vector3(0, 12, 0));
                pos.project(camera);
                
                const isVisible = (pos.z < 1 && this.mesh.position.distanceTo(camera.position) < 80);

                if (isVisible && this.textEl.style.display === 'block') {
                    const x = (pos.x * .5 + .5) * window.innerWidth;
                    const y = (-(pos.y * .5) + .5) * window.innerHeight;
                    this.textEl.style.left = x + 'px';
                    this.textEl.style.top = y + 'px';
                }
            }
            interact() {
                this.textEl.style.display = 'block';
                this.isPaused = true;
                setTimeout(() => { 
                    this.textEl.style.display = 'none'; 
                    this.isPaused = false;
                }, 5000);
            }
            dispose() {
                this.textEl.remove();
                abdGroup.remove(this.mesh);
            }
        }

        function updateAbandoned() {
            dayTime += 1/60; 
            if(dayTime > dayCycleDuration) dayTime = 0;
            const progress = dayTime / dayCycleDuration;
            const angle = progress * Math.PI * 2;
            
            const sunHeight = Math.sin(angle);
            const skyColor = new THREE.Color().setHSL(0.6, 0.2, Math.max(0.02, sunHeight * 0.5));
            const fogColor = new THREE.Color().setHSL(0.6, 0.2, Math.max(0.02, sunHeight * 0.5));
            scene.background = skyColor;
            scene.fog.color = fogColor;

            sunLight.position.set(Math.sin(angle)*100, Math.cos(angle)*100, 0);
            sunLight.intensity = Math.max(0, Math.cos(angle) * 1.5);
            
            if(Math.cos(angle) < -0.2) {
                moonMesh.visible = true;
                moonMesh.position.set(-Math.sin(angle)*200, -Math.cos(angle)*200, 0);
                moonMesh.lookAt(camera.position);
                starSystem.visible = true;
            } else {
                moonMesh.visible = false;
                starSystem.visible = false;
            }
            
            if (!isRaining && Math.random() < 0.001) {
                isRaining = true;
                rainTimer = 127;
                createRain();
            }
            if (isRaining) {
                rainTimer -= 1/60;
                updateRain();
                if (rainTimer <= 0) {
                    isRaining = false;
                    if(rainSystem) { scene.remove(rainSystem); rainSystem.geometry.dispose(); rainSystem = null; }
                }
            }
            
            const hours = Math.floor(progress * 24);
            const mins = Math.floor((progress * 24 % 1) * 60);
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const dispH = hours % 12 || 12;
            const dispM = mins < 10 ? '0'+mins : mins;
            document.getElementById('time-display').innerText = `${dispH}:${dispM} ${ampm}`;

            const cx = Math.floor(camera.position.x / abdChunkSize);
            const cz = Math.floor(camera.position.z / abdChunkSize);
            const viewDist = 1; 
            
            const neededKeys = [];
             for (let dx = -viewDist; dx <= viewDist; dx++) {
                for (let dz = -viewDist; dz <= viewDist; dz++) {
                    neededKeys.push(`${cx + dx},${cz + dz}`);
                }
            }
            
            Object.keys(loadedAbdChunks).forEach(key => {
                if(!neededKeys.includes(key)) {
                    const chunk = loadedAbdChunks[key];
                    chunk.traverse(c => { if(c.geometry) c.geometry.dispose(); });
                    abdGroup.remove(chunk);
                    delete loadedAbdChunks[key];
                }
            });
            
            neededKeys.forEach(key => {
                if(!loadedAbdChunks[key]) {
                    const [kx, kz] = key.split(',').map(Number);
                    const chunk = generateAbdChunk(kx, kz);
                    loadedAbdChunks[key] = chunk;
                    abdGroup.add(chunk);
                }
            });

            npcs.forEach(npc => npc.update());
        }

        function createRain() {
            const geo = new THREE.BufferGeometry();
            const count = 1000;
            const pos = new Float32Array(count * 3);
            for(let i=0; i<count*3; i+=3) {
                pos[i] = (Math.random()-0.5)*100;
                pos[i+1] = Math.random()*50;
                pos[i+2] = (Math.random()-0.5)*100;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color: 0xaaaaaa, size: 0.2, transparent: true, opacity: 0.6});
            rainSystem = new THREE.Points(geo, mat);
            scene.add(rainSystem);
        }

        function updateRain() {
            if(!rainSystem) return;
            const pos = rainSystem.geometry.attributes.position.array;
            for(let i=1; i<pos.length; i+=3) {
                pos[i] -= 1;
                if(pos[i] < -20) pos[i] = 50;
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;
            rainSystem.position.set(camera.position.x, 0, camera.position.z);
        }

        function generateAbdChunk(cx, cz) {
            const group = new THREE.Group();
            const bx = cx * abdChunkSize;
            const bz = cz * abdChunkSize;
            
            const segs = 10;
            const fl = new THREE.PlaneGeometry(abdChunkSize, abdChunkSize, segs, segs);
            const pos = fl.attributes.position;
            for(let i=0; i<pos.count; i++) {
                const x = pos.getX(i) + bx + abdChunkSize/2; 
                const z = -pos.getY(i) + bz + abdChunkSize/2; 
                pos.setZ(i, getTerrainHeight(x, z)); 
            }
            fl.computeVertexNormals();
            fl.rotateX(-Math.PI/2);
            fl.translate(bx + abdChunkSize/2, 0, bz + abdChunkSize/2);
            const flMesh = new THREE.Mesh(fl, new THREE.MeshLambertMaterial({color: 0x222222, flatShading: true}));
            group.add(flMesh);

            const count = 5; 
            const geoms = [
                new THREE.BoxGeometry(1,1,1),
                new THREE.ConeGeometry(1,1,4),
                new THREE.TorusGeometry(1, 0.3, 8, 20),
                new THREE.DodecahedronGeometry(1)
            ];

            for(let i=0; i<count; i++) {
                const s = 10 + pseudoRandom(bx+i, bz+i) * 30;
                const h = 20 + pseudoRandom(bx-i, bz-i) * 60;
                
                let col;
                if(settingMono) {
                    const shade = 0.1 + pseudoRandom(bx*i, bz) * 0.2; 
                    col = new THREE.Color(shade, shade, shade);
                } else {
                    col = new THREE.Color().setHSL(pseudoRandom(bx*i, bz), 0.5, 0.3);
                }

                const gIdx = Math.floor(pseudoRandom(bx, bz+i) * geoms.length);
                const geom = geoms[gIdx].clone();
                const mx = bx + pseudoRandom(bx+i, i) * abdChunkSize;
                const mz = bz + pseudoRandom(bz+i, i) * abdChunkSize;
                const my = getTerrainHeight(mx, mz);
                
                const mesh = new THREE.Mesh(geom, new THREE.MeshLambertMaterial({color: col}));
                mesh.position.set(mx, my + h/2, mz);
                mesh.scale.set(s, h, s);
                if(gIdx === 2) mesh.rotation.x = Math.PI/2; 
                group.add(mesh);
            }

            const debrisCount = 10;
            for(let i=0; i<debrisCount; i++) {
                const dx = bx + Math.random() * abdChunkSize;
                const dz = bz + Math.random() * abdChunkSize;
                const dy = getTerrainHeight(dx, dz);
                const dGeo = new THREE.BoxGeometry(1,1,1);
                const dMesh = new THREE.Mesh(dGeo, new THREE.MeshLambertMaterial({color: 0x555555}));
                dMesh.position.set(dx, dy + 0.5, dz);
                dMesh.scale.set(1+Math.random()*2, 1+Math.random()*2, 1+Math.random()*2);
                dMesh.rotation.set(Math.random(), Math.random(), Math.random());
                group.add(dMesh);
            }

            if(pseudoRandom(cx+0.5, cz+0.5) < settingNpcRate) { 
                 const npcX = bx + abdChunkSize/2;
                 const npcZ = bz + abdChunkSize/2;
                 const npc = new NPC(npcX, npcZ);
                 npcs.push(npc);
            }
            return group;
        }

        function updateCyberMovement() {
            if (!settingCyber) return;

            const speed = isSprinting ? 2.5 : 1.2;
            const direction = new THREE.Vector3();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            if (moveForward || joystickY < -0.2) direction.add(forward);
            if (moveBackward || joystickY > 0.2) direction.sub(forward);
            if (moveRight || joystickX > 0.2) direction.add(right);
            if (moveLeft || joystickX < -0.2) direction.sub(right);

            direction.normalize();

            let velX = 0, velZ = 0;
            if (direction.length() > 0) {
                velX = direction.x * speed;
                velZ = direction.z * speed;
            }

            if (inBackrooms) {
                const nextX = camera.position.x + velX * 2; 
                const nextZ = camera.position.z + velZ * 2;
                if (!checkCollision(nextX, camera.position.z)) {
                    playerVelocity.x = velX;
                } else { playerVelocity.x = 0; }
                
                if (!checkCollision(camera.position.x, nextZ)) {
                    playerVelocity.z = velZ;
                } else { playerVelocity.z = 0; }
                
                playerVelocity.y -= 0.05; 
                if(camera.position.y < -5) {
                    camera.position.y = -5;
                    playerVelocity.y = 0;
                    canJump = true;
                }

            } else if (inAbandoned) {
                playerVelocity.x = velX;
                playerVelocity.z = velZ;
                
                const ty = getTerrainHeight(camera.position.x, camera.position.z);
                const eyeHeight = isCrouching ? 5 : 10;
                
                if (camera.position.y < ty + eyeHeight) {
                    camera.position.y = ty + eyeHeight;
                    playerVelocity.y = 0;
                    canJump = true;
                } else {
                    playerVelocity.y -= 0.05;
                }
                
            } else {
                playerVelocity.x = velX;
                playerVelocity.z = velZ;
                playerVelocity.y -= 0.05; 
                
                const eyeHeight = isCrouching ? 5 : 10;
                const floorLevel = -15 + eyeHeight;
                if (camera.position.y < floorLevel) {
                    playerVelocity.y = 0;
                    camera.position.y = floorLevel;
                    canJump = true;
                }
            }

            camera.position.add(playerVelocity);

            if (flashOn) {
                flashLight.position.copy(camera.position);
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                flashLight.target.position.copy(camera.position).add(camDir);
                flashLight.intensity = document.getElementById('sl-flash-int').value;
            } else {
                flashLight.intensity = 0;
            }

            const compassArrow = document.getElementById('compass-arrow');
            const coordDiv = document.getElementById('coords');
            
            if (compassArrow) {
                 if (inBackrooms || inAbandoned) {
                     document.getElementById('compass').style.display = 'none';
                 } else {
                     document.getElementById('compass').style.display = 'flex';
                     const localPos = currentMesh.position.clone();
                     localPos.applyMatrix4(camera.matrixWorldInverse);
                     const angle = Math.atan2(localPos.x, -localPos.z);
                     const deg = THREE.MathUtils.radToDeg(angle);
                     compassArrow.style.transform = `rotate(${deg}deg)`;
                 }
            }
            if (coordDiv) {
                coordDiv.innerText = `X: ${Math.round(camera.position.x)} Y: ${Math.round(camera.position.z)}`;
            }
        }
        
        document.getElementById('coords').addEventListener('click', () => {
            if(!settingCyber) return;
            const input = prompt("Enter coordinates (x, z):", "0, 0");
            if(input) {
                const [x, z] = input.split(',').map(n => parseFloat(n.trim()));
                if(!isNaN(x) && !isNaN(z)) {
                    camera.position.x = x;
                    camera.position.z = z;
                    if(inAbandoned) camera.position.y = getTerrainHeight(x, z) + 20;
                    else camera.position.y = 10;
                    if(inBackrooms) { loadedChunks = {}; brGroup.clear(); updateBackrooms(); }
                    if(inAbandoned) { loadedAbdChunks = {}; abdGroup.clear(); updateAbandoned(); }
                }
            }
        });
        
        document.getElementById('time-display').addEventListener('click', () => {
            const t = prompt("Set Time (0-24):", "12");
            const h = parseFloat(t);
            if(!isNaN(h) && h >= 0 && h <= 24) {
                dayTime = (h / 24) * dayCycleDuration;
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            drawCanvas();
            updateDominos();
            updatePhysics();
            updateCyberMovement();
            
            if(inBackrooms) updateBackrooms();
            if(inAbandoned) updateAbandoned();

            if (!settingCyber) {
                controls.enabled = !isDragging;
                controls.update();
                renderer.render(scene, camera);
            } else {
                controls.enabled = false;
                if (settingBloom) {
                    composer.render();
                } else {
                    renderer.render(scene, camera);
                }
            }
        }

        initGrid();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        const uiWrapper = document.getElementById('ui-wrapper');
        const uiToggleBtn = document.getElementById('ui-toggle-btn');
        const btnAimToggle = document.getElementById('btn-aim-toggle');
        
        function toggleSettings() {
             uiWrapper.classList.toggle('open');
        }

        uiToggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSettings();
        });
        
        document.addEventListener('click', (e) => {
             if (uiWrapper.classList.contains('open') && !uiWrapper.contains(e.target)) {
                 uiWrapper.classList.remove('open');
             }
        });

        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        function switchTab(targetId) {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            const activeTab = document.querySelector(`[data-target="${targetId}"]`);
            if(activeTab) activeTab.classList.add('active');
            const content = document.getElementById(targetId);
            if(content) content.classList.add('active');
        }
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => switchTab(tab.dataset.target));
        });

        function syncInput(sliderId, numId, callback) {
            const s = document.getElementById(sliderId);
            const n = document.getElementById(numId);
            s.addEventListener('input', () => { n.value = s.value; if(callback) callback(s.value); });
            n.addEventListener('input', () => { s.value = n.value; if(callback) callback(n.value); });
        }

        document.getElementById('btn-shape').addEventListener('click', (e) => {
            isSphere = !isSphere;
            const oldPos = currentMesh.position.clone();
            const oldRot = currentMesh.rotation.clone();
            const oldScale = currentMesh.scale.clone();
            scene.remove(currentMesh);
            currentMesh = new THREE.Mesh(isSphere ? geometrySphere : geometryBox, material);
            currentMesh.position.copy(oldPos);
            currentMesh.rotation.copy(oldRot);
            currentMesh.scale.copy(oldScale);
            currentMesh.castShadow = true;
            currentMesh.receiveShadow = true;
            scene.add(currentMesh);
            e.target.innerText = isSphere ? "Toggle Shape: Sphere" : "Toggle Shape: Cube";
        });
        document.getElementById('col-mesh').addEventListener('input', (e) => { meshColor = e.target.value; staticNeedsUpdate = true; });
        document.getElementById('col-grid').addEventListener('input', (e) => { gridColor = e.target.value; staticNeedsUpdate = true; });
        document.getElementById('chk-grid').addEventListener('change', (e) => { settingShowGrid = e.target.checked; staticNeedsUpdate = true; });
        
        syncInput('sl-grid-thick', 'num-grid-thick', (v) => { settingGridThick = parseFloat(v); staticNeedsUpdate = true; });

        document.getElementById('chk-chars').addEventListener('change', (e) => { settingShowChars = e.target.checked; });
        
        syncInput('sl-grid', 'num-grid', (v) => { updateGridSize(v); });
        
        function updateGridSize(val) {
            const v = parseInt(val);
            if (v < 2) return;
            rows = v;
            initGrid();
        }
        
        syncInput('sl-scale', 'num-scale', (v) => {
            const s = parseFloat(v);
            currentMesh.scale.set(s,s,s);
        });

        syncInput('sl-res', 'num-res', (v) => { renderer.setPixelRatio(window.devicePixelRatio * parseFloat(v)); });

        document.getElementById('col-sky').addEventListener('input', (e) => { 
            scene.background = new THREE.Color(e.target.value); 
            scene.fog.color = new THREE.Color(e.target.value);
        });
        
        syncInput('sl-luminance', 'num-luminance', (v) => { ambientLight.intensity = parseFloat(v); });
        document.getElementById('col-floor').addEventListener('input', (e) => { floorMesh.material.color.set(e.target.value); });

        const btnShuffle = document.getElementById('btn-shuffle');
        document.getElementById('chk-randomizer').addEventListener('change', (e) => { 
            settingRandomizer = e.target.checked;
            btnShuffle.disabled = settingRandomizer;
        });
        btnShuffle.addEventListener('click', () => {
             for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (!gridData[y][x].frozen) gridData[y][x].char = chars[Math.floor(Math.random() * chars.length)];
                }
            }
        });
        document.getElementById('chk-spread').addEventListener('change', (e) => { settingSpread = e.target.checked; });

        const mobileUi = document.getElementById('mobile-ui');
        const interactionUi = document.getElementById('interaction-ui');
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const cyberTabBtn = document.getElementById('tab-cyber-btn');
        const rowFloor = document.getElementById('row-floor');
        const rowGravity = document.getElementById('row-gravity');
        const cyberOverlay = document.getElementById('cyber-overlay');
        const crosshair = document.getElementById('crosshair');
        const hudLeft = document.getElementById('hud-top-left');
        const btnBackrooms = document.getElementById('btn-backrooms');
        const btnGrab = document.getElementById('m-grab');
        const timeDisplay = document.getElementById('time-display');
        
        let overlayTimeout;

        document.getElementById('chk-physics').addEventListener('change', (e) => { 
            settingPhysics = e.target.checked;
            floorMesh.visible = settingPhysics && !inBackrooms && !inAbandoned;
            
            if (settingPhysics) {
                rowFloor.classList.add('visible');
                rowGravity.classList.add('visible');
                cyberTabBtn.classList.add('visible');
                if(isMobile) interactionUi.style.display = 'flex';
            } else {
                rowFloor.classList.remove('visible');
                rowGravity.classList.remove('visible');
                cyberTabBtn.classList.remove('visible');
                if (document.getElementById('tab-cyber').classList.contains('active')) {
                    switchTab('tab-visual');
                }
                currentMesh.position.set(0,0,0);
                currentMesh.rotation.set(0,0,0);
                settingCyber = false;
                document.getElementById('chk-cyberspace').checked = false;
                exitCyberMode();
                if(isMobile) interactionUi.style.display = 'none';
            }
        });
        
        syncInput('sl-gravity', 'num-gravity', (v) => { settingGravity = parseFloat(v); });

        const chkCyber = document.getElementById('chk-cyberspace');
        chkCyber.addEventListener('change', (e) => {
            settingCyber = e.target.checked;
            if (settingCyber) {
                uiWrapper.classList.add('cyber-mode');
                uiWrapper.classList.remove('open'); 
                camera.position.y = -5;
                camera.lookAt(0, 0, 0);
                btnBackrooms.style.display = 'block';
                
                document.getElementById('sl-luminance').value = 1;
                document.getElementById('num-luminance').value = 1;
                ambientLight.intensity = 1;

                if (isMobile) {
                    mobileUi.style.display = 'block';
                } else {
                    cyberOverlay.style.display = 'block';
                    crosshair.style.display = 'block';
                    
                    cyberOverlay.style.opacity = '1';
                    if (overlayTimeout) clearTimeout(overlayTimeout);
                    overlayTimeout = setTimeout(() => {
                        cyberOverlay.style.opacity = '0';
                        setTimeout(() => { if(cyberOverlay.style.opacity === '0') cyberOverlay.style.display = 'none'; }, 1000);
                    }, 5000);
                }
                hudLeft.style.display = 'flex';
            } else {
                exitCyberMode();
            }
        });

        btnAimToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleAimLock();
        });

        function toggleAimLock() {
            if (!settingCyber || isMobile) return;
            aimLocked = !aimLocked;
            if (aimLocked) {
                document.body.requestPointerLock();
                btnAimToggle.classList.add('active');
            } else {
                document.exitPointerLock();
                btnAimToggle.classList.remove('active');
            }
        }
        document.addEventListener('pointerlockchange', () => {
             if(document.pointerLockElement !== document.body) {
                 aimLocked = false;
                 btnAimToggle.classList.remove('active');
             } else {
                 aimLocked = true;
                 btnAimToggle.classList.add('active');
             }
        });

        function exitCyberMode() {
            uiWrapper.classList.remove('cyber-mode');
            flashOn = false;
            flashLight.intensity = 0;
            mobileUi.style.display = 'none';
            cyberOverlay.style.display = 'none';
            crosshair.style.display = 'none';
            hudLeft.style.display = 'none';
            btnBackrooms.style.display = 'none';
            timeDisplay.style.display = 'none';
            aimLocked = false;
            btnAimToggle.classList.remove('active');
            
            inBackrooms = false; inAbandoned = false;
            sunLight.intensity = 0; 
            resetWorldState();

            if (document.pointerLockElement === document.body) document.exitPointerLock();
            camera.position.set(0, 0, 25);
            camera.lookAt(0, 0, 0);
            isHoldingDesktop = false;
            if(overlayTimeout) clearTimeout(overlayTimeout);
            camera.rotation.set(0,0,0);
        }

        function resetWorldState() {
             currentMesh.visible = true;
             floorMesh.visible = true;
             brGroup.visible = false;
             abdGroup.visible = false;
             btnBackrooms.innerText = "ENTER ROOMS";
             btnBackrooms.style.background = "#520";
             
             scene.fog.color.set(document.getElementById('col-sky').value);
             scene.background.set(document.getElementById('col-sky').value);
             ambientLight.intensity = 1;
             renderer.setPixelRatio(window.devicePixelRatio * parseFloat(document.getElementById('sl-res').value));
        }
        
        btnBackrooms.addEventListener('click', () => {
             toggleBackrooms();
        });

        function toggleBackrooms() {
            if(inAbandoned) {
                inAbandoned = false;
                enterBackrooms();
                return;
            }

            if(inBackrooms) {
                inBackrooms = false;
                resetWorldState();
            } else {
                enterBackrooms();
            }
        }

        function enterBackrooms() {
            inBackrooms = true;
            btnBackrooms.innerText = "LEAVE ROOMS";
            btnBackrooms.style.background = "#250";
            currentMesh.visible = false;
            floorMesh.visible = false;
            brGroup.visible = true;
            abdGroup.visible = false;
            timeDisplay.style.display = 'none';
            if(isMobile) btnGrab.innerText = "E";
            
            ambientLight.intensity = 0.2;
            sunLight.intensity = 0; 

            renderer.setPixelRatio(window.devicePixelRatio * 0.5);
            document.getElementById('sl-res').value = 0.5;
            document.getElementById('num-res').value = 0.5;

            loadedChunks = {};
            brGroup.clear();
            interactables = [];
            
            camera.position.x = Math.random() * 1000;
            camera.position.z = Math.random() * 1000;
        }

        function enterAbandoned() {
            inBackrooms = false;
            inAbandoned = true;
            brGroup.visible = false;
            abdGroup.visible = true;
            timeDisplay.style.display = 'block';
            if(isMobile) btnGrab.innerText = "GRAB"; 
            
            scene.background.setHex(0x808080);
            scene.fog.color.setHex(0x808080);
            ambientLight.intensity = 0.35;
            renderer.setPixelRatio(window.devicePixelRatio * 0.5);
            
            loadedAbdChunks = {};
            abdGroup.clear();
            npcs = [];
            
            const h = getTerrainHeight(camera.position.x, camera.position.z);
            camera.position.y = h + 10; 
        }

        document.getElementById('col-flash').addEventListener('input', (e) => { flashLight.color.set(e.target.value); });
        syncInput('sl-flash-int', 'num-flash-int', null);
        syncInput('sl-flash-dist', 'num-flash-dist', (v) => { flashLight.distance = parseFloat(v); });
        syncInput('sl-flash-angle', 'num-flash-angle', (v) => { flashLight.angle = parseFloat(v); });
        
        document.getElementById('chk-bloom').addEventListener('change', (e) => {
            settingBloom = e.target.checked;
        });
        syncInput('sl-bloom', 'num-bloom', (v) => { bloomPass.strength = parseFloat(v); });
        
        document.getElementById('chk-mono').addEventListener('change', (e) => {
            settingMono = e.target.checked;
            loadedAbdChunks = {};
            abdGroup.clear();
            npcs = []; 
            interactables = interactables.filter(obj => !obj.userData.npc); 
        });
        
        syncInput('sl-npc-rate', 'num-npc-rate', (v) => { settingNpcRate = parseFloat(v); });

        syncInput('sl-view-dist', 'num-view-dist', (v) => { 
            camera.far = parseFloat(v); 
            scene.fog.far = parseFloat(v);
            camera.updateProjectionMatrix();
        });

        document.addEventListener('keydown', (e) => {
            if (!settingCyber) return;
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump) { playerVelocity.y = 1.0; canJump = false; } break;
                case 'ShiftLeft': isSprinting = true; break;
                case 'KeyC': isCrouching = true; break;
                case 'KeyF': flashOn = !flashOn; break;
                case 'AltLeft': 
                case 'AltRight':
                    e.preventDefault();
                    toggleAimLock(); 
                    break;
                case 'KeyT': 
                    if (isHoldingDesktop) {
                         releaseObject(2); 
                         isHoldingDesktop = false;
                    }
                    break;
                case 'KeyE':
                     interactRaycast();
                     break;
            }
        });
        document.addEventListener('keyup', (e) => {
            if (!settingCyber) return;
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSprinting = false; break;
                case 'KeyC': isCrouching = false; break;
            }
        });

        function interactRaycast() {
             raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
             const interactHits = raycaster.intersectObjects(interactables, true); 
             if (interactHits.length > 0 && interactHits[0].distance < 20) {
                 const obj = interactHits[0].object;
                 let target = obj;
                 while(target.parent && !target.userData.type && !target.userData.npc) {
                     target = target.parent;
                 }
                 if (target.userData.type === 'door') {
                     enterAbandoned();
                     return;
                 }
                 if (target.userData.npc) {
                     target.userData.npc.interact();
                     return;
                 }
             }
        }

        document.addEventListener('mousedown', (e) => {
            if (!settingCyber || isMobile || e.target.closest('#ui-wrapper')) return;

            if (e.button === 0) {
                const rayMouse = new THREE.Vector2();
                
                if (document.pointerLockElement === document.body || aimLocked) {
                    rayMouse.set(0, 0); 
                } else {
                    rayMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    rayMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                }
                
                raycaster.setFromCamera(rayMouse, camera); 
                const interactHits = raycaster.intersectObjects(interactables, true); 
                
                if (interactHits.length > 0 && interactHits[0].distance < 20) {
                     const obj = interactHits[0].object;
                     let target = obj;
                     while(target.parent && !target.userData.type && !target.userData.npc) {
                         target = target.parent;
                     }
                     if (target.userData.type === 'door') {
                         enterAbandoned();
                         return;
                     }
                     if (target.userData.npc) {
                         target.userData.npc.interact();
                         return;
                     }
                }

                const intersects = raycaster.intersectObject(currentMesh);
                if (intersects.length > 0 && currentMesh.position.distanceTo(camera.position) < 25 && !inBackrooms && !inAbandoned) {
                    isHoldingDesktop = true;
                    holdDistance = currentMesh.position.distanceTo(camera.position);
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (!settingCyber || isMobile) return;
            if (e.button === 0) {
                isHoldingDesktop = false;
            }
        });
        
        document.addEventListener('wheel', (e) => {
            if (!settingCyber) return;
            if (isHoldingDesktop) {
                holdDistance -= e.deltaY * 0.01;
                if (holdDistance < 2) holdDistance = 2;
                if (holdDistance > 30) holdDistance = 30;
            }
        });

        document.addEventListener('contextmenu', (e) => { e.preventDefault(); });

        document.addEventListener('mousemove', (e) => {
            if (settingCyber && !isMobile) {
                if (aimLocked || (e.buttons & 2) === 2 || document.pointerLockElement === document.body) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            }
        });

        const joystickArea = document.getElementById('joystick-area');
        const joystickStick = document.getElementById('joystick-stick');
        let joystickX = 0, joystickY = 0, joystickTouchId = null;

        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joystickTouchId = touch.identifier;
            updateJoystick(touch.clientX, touch.clientY);
        });
        joystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            for (let i=0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystickTouchId) updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
            }
        });
        joystickArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickX = 0; joystickY = 0;
            joystickStick.style.transform = `translate(-50%, -50%)`;
        });
        function updateJoystick(x, y) {
            const rect = joystickArea.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            let dx = x - centerX, dy = y - centerY;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 35);
            const angle = Math.atan2(dy, dx);
            joystickStick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
            joystickX = (Math.cos(angle)*dist) / 35;
            joystickY = (Math.sin(angle)*dist) / 35;
        }

        let touchStartDist = 0;
        document.addEventListener('touchstart', (e) => {
            if(!settingCyber || !isMobile) return;
            
            if (e.touches.length === 2 && isHoldingMobile) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx*dx + dy*dy);
            }

            if(e.target.closest('#mobile-buttons') || e.target.closest('#joystick-area') || e.target.closest('#ui-wrapper') || e.target.closest('#interaction-ui')) return;

            const touch = e.touches[0];
            if(touch.clientX > window.innerWidth / 2) {
                isLooking = true;
                lastLookX = touch.clientX;
                lastLookY = touch.clientY;
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if(!settingCyber || !isMobile) return;

            if (e.touches.length === 2 && isHoldingMobile) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const delta = dist - touchStartDist;
                holdDistance += delta * 0.05;
                if(holdDistance < 2) holdDistance = 2;
                if(holdDistance > 30) holdDistance = 30;
                touchStartDist = dist;
                return; 
            }

            if(!isLooking) return;
            const touch = e.touches[0];
            const deltaX = touch.clientX - lastLookX;
            const deltaY = touch.clientY - lastLookY;
            camera.rotation.y -= deltaX * 0.005;
            camera.rotation.x -= deltaY * 0.005;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            lastLookX = touch.clientX;
            lastLookY = touch.clientY;
        });

        document.addEventListener('touchend', () => { isLooking = false; });

        document.getElementById('m-sprint').addEventListener('touchstart', (e)=>{ e.preventDefault(); isSprinting=true; });
        document.getElementById('m-sprint').addEventListener('touchend', (e)=>{ e.preventDefault(); isSprinting=false; });
        document.getElementById('m-jump').addEventListener('touchstart', (e)=>{ e.preventDefault(); if(canJump){playerVelocity.y=1.0; canJump=false;} });
        document.getElementById('m-crouch').addEventListener('touchstart', (e)=>{ e.preventDefault(); isCrouching=true; });
        document.getElementById('m-crouch').addEventListener('touchend', (e)=>{ e.preventDefault(); isCrouching=false; });
        document.getElementById('m-flash').addEventListener('touchstart', (e)=>{ e.preventDefault(); flashOn=!flashOn; });

        const btnDrop = document.getElementById('m-drop');
        const btnThrow = document.getElementById('m-throw');

        btnGrab.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(inBackrooms || inAbandoned) {
                interactRaycast();
            } else {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
                const intersects = raycaster.intersectObject(currentMesh);
                if (currentMesh.position.distanceTo(camera.position) < 25 && !inBackrooms && !inAbandoned) {
                    isHoldingMobile = true;
                    holdDistance = currentMesh.position.distanceTo(camera.position);
                    btnGrab.style.display = 'none';
                    btnDrop.style.display = 'flex';
                    btnThrow.style.display = 'flex';
                }
            }
        });

        btnDrop.addEventListener('touchstart', (e) => { e.preventDefault(); releaseObject(0); });
        btnThrow.addEventListener('touchstart', (e) => { e.preventDefault(); releaseObject(2); });

        function releaseObject(power) {
            isHoldingMobile = false;
            btnGrab.style.display = 'flex';
            btnDrop.style.display = 'none';
            btnThrow.style.display = 'none';
            if (power > 0) {
                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                objVelocity.copy(forward).multiplyScalar(power);
                objVelocity.y += 0.5; 
            }
        }

        window.addEventListener('pointerdown', (event) => {
            if (event.target.closest('#ui-wrapper') || event.target.closest('#mobile-ui') || settingCyber) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentMesh);
            if (intersects.length > 0) {
                if (settingPhysics) {
                    isDragging = true;
                    controls.enabled = false;
                    dragPlane.normal.copy(camera.position).normalize();
                    dragPlane.constant = -currentMesh.position.dot(dragPlane.normal);
                    raycasterPlane.setFromCamera(mouse, camera);
                    const planeIntersect = new THREE.Vector3();
                    raycasterPlane.ray.intersectPlane(dragPlane, planeIntersect);
                    previousDragPosition.copy(planeIntersect);
                } else {
                    const uv = intersects[0].uv;
                    let col = Math.floor(uv.x * cols);
                    let row = Math.floor((1 - uv.y) * rows);
                    if (col >= cols) col = cols - 1; if (row >= rows) row = rows - 1;
                    if (row >= 0 && row < rows && col >= 0 && col < cols) {
                        if (settingSpread) {
                            const cell = gridData[row][col];
                            const newState = !cell.frozen;
                            activeWaveState = newState;
                            cell.frozen = newState;
                            if (newState) cell.frozenChar = cell.char;
                        } else {
                            const isPaused = gridData[0][0].frozen; 
                            const newState = !isPaused;
                            for (let y = 0; y < rows; y++) {
                                for (let x = 0; x < cols; x++) {
                                    gridData[y][x].frozen = newState;
                                    if (newState) gridData[y][x].frozenChar = gridData[y][x].char;
                                }
                            }
                        }
                    }
                }
            }
        });
        window.addEventListener('pointermove', (event) => {
            if (isDragging && settingPhysics && !settingCyber) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycasterPlane.setFromCamera(mouse, camera);
                const planeIntersect = new THREE.Vector3();
                raycasterPlane.ray.intersectPlane(dragPlane, planeIntersect);
                if (planeIntersect) {
                    const delta = new THREE.Vector3().subVectors(planeIntersect, previousDragPosition);
                    currentMesh.position.add(delta);
                    objVelocity.copy(delta);
                    previousDragPosition.copy(planeIntersect);
                }
            }
        });
        window.addEventListener('pointerup', () => {
            if (isDragging) { isDragging = false; controls.enabled = true; objVelocity.multiplyScalar(2); }
        });
    </script>
</body>
</html>
